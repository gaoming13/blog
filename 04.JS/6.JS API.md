### Atomics
```js
const workerScriptBlobUrl = URL.createObjectURL(new Blob([`
  self.onmessage = ({data}) => {
    const view = new Uint32Array(data);
    for (let i = 1; i <= 1000; i++) {
      // view[0] += 1;
      // 原子操作
      Atomics.add(view, 0, 1);
    }
  };
`]));
const buffer = new SharedArrayBuffer(4);
const view = new Uint32Array(buffer); view[0] = 0;
for (let i = 1; i <= 10; i++) {
  const woker = new Worker(workerScriptBlobUrl);
  woker.postMessage(buffer);
}
setTimeout(() => console.log(view[0]), 1000);
```
- 多个上下文访问 SharedArrayBuffer 时,同时对缓冲区执行操作,可能出现资源争用问题
- Atomics通过强制同一时刻只能对缓冲区执行一个操作

### 跨上下文消息
```js
const iframeWin = document.querySelector('iframe').contentWindow;
iframeWin.postMessage({a: 123, b: 456}, '*');
```
- 简称 XDM(cross-document messaging),一种在不同执行上下文(不同工作线程/不同源的页面)间传递信息的能力
- postMessage(消息, 目标接收源的字符串);

### Encoding API
- 用于字符串与定型数组之间的转换
- 文本编码
  - 批量编码
    - TextEncoder.prototype.encode(字符串)
      ```js
      const textEncoder = new TextEncoder();
      textEncoder.encode('😄f中');
      // Uint8Array(8) [240, 159, 152, 132, 102, 228, 184, 173]
      encodeURIComponent('😄f中');
      // %F0%9F%98%84 f %E4%B8%AD
      // parseInt('F0', 16) = 240 = 11110000
      // parseInt('9F', 16) = 159 = 10011111
      // parseInt('98', 16) = 152 = 10011000
      // parseInt('84', 16) = 132 = 10000100
      // 'f'.codePointAt()  = 102 = 01100110
      // parseInt('E4', 16) = 228 = 11100100
      // parseInt('B8', 16) = 184 = 10111000
      // parseInt('AD', 16) = 173 = 10101101
      ```
    - TextEncoder.prototype.encodeInto(字符串, 目标Unit8Array)
      ```js
      const textEncoder = new TextEncoder();
      const arr = new Uint8Array(3);
      const res = textEncoder.encodeInto('f中', arr);
      // res: {read: 1, written: 1}
      // arr: Uint8Array(3) [102, 0, 0]
      ```
  - 流编码
    - TextEncoderStream 将解码后的文本流通过管道输入流编码器得到编码后文本块的流
    ```js
    async function * chars() {
      const decodedText = 'foo';
      for (let char of decodedText) {
        yield await new Promise((resolve) => {
          setTimeout(resolve, 1000, char);
        });
      }
    }
    // 文本流
    const textStream = new ReadableStream({
      async start(constroller) {
        for await (const v of chars()) {
          constroller.enqueue(v);
        }
        constroller.close();
      }
    });
    // 编码后文本块的流
    const encodeTextStream = textStream.pipeThrough(new TextEncoderStream());
    // 读取文本块流
    const reader = encodeTextStream.getReader();
    (async () => {
      while(true) {
        const res = await reader.read();
        if (res.done) break;
        console.log(res);
      }
    })();
    ```
- 文本解码
  - 与编码器类不同，在将定型数组转换为字符串时，解码器支持非常多的字符串编码(默认UTF-8)
  - 批量解码
    ```js
    const textDecoder = new TextDecoder('utf-8');
    textDecoder.decode(Uint8Array.of(102, 111, 111)); // foo
    ```
  - 流解码
    - 将编码后的文本流通过管道 输入流解码器会得到解码后文本块的流
    - 解码器流会保持块片段指导取到完整的字符
    ```js
    async function* chars() {
      for (const u8 of [240, 159, 152, 132, 102, 228, 184, 173]) {
        yield await new Promise((resolve) => setTimeout(resolve, 100, Uint8Array.of(u8)));
      }
    }
    // 文本流
    const textStream = new ReadableStream({
      async start(constroller) {
        for await (const u8 of chars()) {
          constroller.enqueue(u8);
        }
        constroller.close();
      }
    });
    // 流过管道解码
    const decodeTextStream = textStream.pipeThrough(new TextDecoderStream());
    // 读取
    const reader = decodeTextStream.getReader();
    (async () => {
      while(true) {
        const res = await reader.read();
        if (res.done) break;
        console.log(res);
      }
    })();
    ```




> https://developer.mozilla.org/zh-CN/docs/Web/API/Performance_API
### Performance API 高采样率
- 全局变量 performance 是 Performance 的实例对象
- 原型属性(Performance.prototype)
  - performance.timing 返回一个 PerformanceTiming 对象, 与延时相关的性能信息
  - performance.navigation
- 原型方法(Performance.prototype) 返回一个 PerformanceNavigation 对象, 在给定浏览上下文中发生的导航类型
  - performance.now() 返回创建浏览器上下文的时间(单位ms,精确到5us微秒)
  - performance.getEntries({name: "entry_name", entryType: "mark"}) 筛选获取 PerformanceEntry 数组
  - performance.mark('标记1') 创建标记
  - performance.mark('标记2') 创建标记
  - performance.measure('间距1', '标记1', '标记2');
  - performance.getEntriesByName('间距1')[0].duration;
  - performance.clearMarks() 删除所有标记
  - performance.clearMeasures() 删除所有测量

### PerformanceEntry
- 代表了 performance 时间列表中每个 metric 数据
- 可手动构建 mark 或 measure 主动生成
- 在资源加载的时候, 也会被动生成(如图片、js、css等资源加载)
- 原型属性
  - name 名字
  - entryType 上报类型(frame、navigation、resource、mark、measure、paint)
  - startTime 上报开始的时间(ms)
  - duration 耗时(ms)