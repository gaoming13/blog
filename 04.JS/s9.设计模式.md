> JavaScript设计模式与开发实践.pdf
> https://www.runoob.com/design-pattern/factory-pattern.html
## 设计模式分类
- 1.创建者模式：提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象
- 2.结构型模式：类与对象的组合
- 3.行为型模式：对象之间的通信
- 4.J2EE模式：关注表示层，这些模式由 Sun Java Center 鉴定

## 涉及模式

### 1-1.工厂模式(创建型模式)
- 原理：创建对象时不会对客户端暴露创建逻辑，并且是通过一个共同的接口来指向新创建的对象
  - 你需要一辆汽车，可以直接从工厂里面提货，而不用管理这辆汽车怎么做出来的，以及汽车里面的具体实现
- 关键代码：创建代码在其子类执行
- 优点：
  - 1.一个调用者想创建一个对象，只要知道其名称就可以了，屏蔽产品实现的细节
  - 2.扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以
- 缺点：
  - 1.每增加一个产品时，就需要增加一个具体类和对象实现工厂，一定程度增加了系统的复杂度
- 注意：复杂对象适合工厂模式，而简单对象，直接new就行了
- 场景：
  - 1.browserStorage的逻辑
  - 2.Redis实例封装，设置配置项的逻辑隐藏起来，只返还给一个对象
- 实例：
  ```js
  class Dog { name = 'Wang'; }
  class Duck { name = 'GaGa'; }
  class Animal {
    static get(type) {
      if (type === 'dog') return new Dog();
      if (type === 'duck') return new Duck();
      return null;
    }
  }
  Animal.get('duck');
  Animal.get('dog');
  ```

### 1-2.单例模式(创建型模式)
- 原理：保证一个类只有一个实例，并提供一个访问它的全局访问点
- 关键代码：构造函数是私有的
- 优点：
  - 1.内存中只有一个实例，叫少了内存的消耗，尤其是频繁的创建和销毁实例
- 缺点：
  - 1.没有接口，不能继承，与单一职责原则冲突，一个类应只关心内部逻辑，而不关心外部怎样实例化
- 注意：
  - getInstance() 方法中需要使用同步锁
  - 缓存击穿：没有实例的时候，并发请求过来，同时创建
    - 封装请求(第一个没请求完，让其它的请求等待，轮询查询/订阅模式)
- 场景：
  - 1.Redis/MySQL 单连接

### 1-3.原型模式(创建型模式)
- 原理：利用已有的一个原型对象，快速地生成和原型对象一样的示例
- 场景：
  - 1.类的初始化非常耗费资源
  - 2.一般和工厂方法模式一起使用，通过clone方法创建一个对象，然后由工厂方法提供给调用者
- 注意：
  - 与通过类实例化构造新对象不同，原型是通过拷贝一个现有对象来生成新对象，浅拷贝/深拷贝
- 实例：
  ```js
  class Dog {
    age = 13;
    constructor(name) {
      this.name = name;
    }
  }
  let dog1 = new Dog('dog1');
  // 1.通过Object.create
  let dog2 = Object.create(dog1, {
    color: { value: 'red' },
  });
  // 2.通过prototype
  let dog2 = {};
  Object.setPrototypeOf(dog2, dog1);
  Object.defineProperties(dog2, {
    color: { value: 'red' }
  })
  ```

### 2-1.适配器模式(结构型模式)
- 原理：为了适配，改变原有的接口方法
- 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口
- 优点：
  - 1.可以让两个没有关联的类一起运行，灵活性好
- 缺点：
  - 1.过多的使用适配器，会让系统非常零乱
- 实例：
  - 1.页面里事件track收集脚本(mixpanel/umeng)

### 2-2.装饰器模式(结构型模式)
- 原理：为了增加功能，动态给对象添加一些额外的职责
  - 就增加功能来说，装饰器模式比生成子类更灵活

### 2-3.代理模式(结构型模式)
- 原理：为了控制，想再访问一个类的时做一些控制
- 关键代码：实现与被代理类的组合
- 场景：
  - 1.刘备给诸葛亮送草鞋，门童代理
  - 2.开车(未满18岁限制)
  - 3.批量写数据、请求(数量太少，代理人先攒起来)
- 注意：
  - 与适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变代理类的接口
  - 与装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制

### 3-1.策略模式(行为型模式)
- 原理：定义一系列的算法，把他们一个个封装起来，使它们可相互替换
- 关键代码：实现同一个接口
- 优点：
  - 1.算法可自由切换
  - 2.避免使用多重条件判断
  - 3.扩展性良好
- 缺点
  - 1.策略类会增多
  - 2.所有策略类都需要对外暴露
- 注意：如果一个系统中策略多于4个，就需要考虑混合模式，解决策略类膨胀的问题
- 场景：
  - 1.后端框架中，缓存方式的选择
  - 2.big-decimal.js中的round方法(number, precision, mode)

### 3-2.迭代器模式(行为型模式)
- 原理：提供一个方法书许访问集合对象的元素，而无需暴露该对象的内部表示
- 关键代码：实现 [Symbol.iterator] 接口

### 3-3.观察者模式(发布-订阅模式)(行为型模式)
- 原理：定义对象间一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都将得到通知
  - JS中，一般用事件模型来替代传统的发布-订阅模式
- 优点：
  - 1.易用且低耦合，保证高度的协作
- 缺点：
  - 1.有许多观察者或间接观察者的话，所有的观察者都通知会花费很多时间
  - 2.如果观察者和观察目标之间有循环依赖的话，会循环调用，导致系统崩溃
- 场景：
  - 1.前台页面调用接口(第一个去请求/后面等待)
  - 2.js addEventListener
- 注意：
  - 1.避免循环引用
  - 2.如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式
- 示例：
  ```js
  class Event1 {
    // 事件的订阅者
    eventSubs = {};
    // 事件订阅
    on(evt, callback) {
      if (! this.eventSubs[evt]) this.eventSubs[evt] = [];
      this.eventSubs[evt].push(callback);
    }
    // 事件订阅移除
    remove(evt, callback) {
      if (! this.eventSubs[evt]) return;
      this.eventSubs[evt] = this.eventSubs[evt].filter(v => v !== callback);
    }
    // 事件触发
    emit(evt, ...args) {
      let subs = this.eventSubs[evt] ? this.eventSubs[evt] : [];
      for (const sub of subs) {
        sub(args);
      }
    }
  }
  let event1 = new Event1();
  const f1 = function(e) {
    console.log(['1', e]);
  };
  event1.on('click', f1);
  event1.remove('click', f1);
  event1.on('click', function(e) {
    console.log(['2', e]);
  });
  event1.emit('click', 1, 2, 3);
  ```

### 3-4.命令模式(行为型模式) ???
- 原理：用松耦合的方式来设计程序，让请求发送者和请求接受者能够消除彼此之间的耦合关系

### 3-5.状态模式(行为型模式)
- 原理：类的行为是基于它的状态改变的
  - 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类
- 实例：
  - 1.电灯只有一个开关，第一次按下打开弱光，第二次按下打开强光，第三次按下关闭