## JavaScript 标准内置对象、以及它们它们的方法和属性
- 这里的 标准内置对象 不应与 全局对象(Global Object) 混淆
- 全局对象的属性 = 标准内置对象 + 用户脚本创建的 + 宿主程序提供的
  - 浏览器中: window / self / frames 是全局对象
  - Node.js 中: global 是全局对象
  - Web Workers 中: self 是全局变量
  - 在松散模式下，可以在函数中返回 this 来获取全局变量，但严格模式下和模块环境下，this 会返回 undefined
  - globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）

## 标准内置对象分类
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN
- Global对象的函数
  - eval
  - isFinite
  - isNaN
  - parseFloat
  - parseInt
  - decodeURI
  - decodeURIComponent
  - encodeURI
  - encodeURIComponent
- 对象:基本
  - Object
  - Function
  - Boolean
  - Symbol
- 对象:错误
  - Error
  - AggregateError
  - EvalError
  - InternalError
  - RangeError
  - ReferenceError
  - SyntaxError
  - TypeError
  - URIError
- 对象:数字和日期
  - Number
  - BigInt
  - Math
  - Date
- 对象:字符串
  - String
  - RegExp
- 对象:数组
  - Array
  - Int8Array
  - Uint8Array
  - Uint8ClampedArray
  - Int16Array
  - Uint16Array
  - Int32Array
  - Uint32Array
  - Float32Array
  - Float64Array
  - BigInt64Array
  - BigUint64Array
- 对象:集合
  - Map
  - Set
  - WeakMap
  - WeakSet
- 对象:结构化
  - ArrayBuffer
  - SharedArrayBuffer
  - Atomics
  - DataView
  - JSON
- 对象:控制抽象
  - Promise
  - Generator
  - GeneratorFunction
  - AsyncFunction
- 对象:反射
  - Reflect
  - Proxy
- 对象:国际化
  - Intl
  - Intl.Collator
  - Intl.DateTimeFormat
  - Intl.ListFormat
  - Intl.NumberFormat
  - Intl.PluralRules
  - Intl.RelativeTimeFormat
  - Intl.Locale
- 对象:WebAssembly
  - WebAssembly
  - WebAssembly.Module
  - WebAssembly.Instance
  - WebAssembly.Memory
  - WebAssembly.Table
  - WebAssembly.CompileError
  - WebAssembly.LinkError (en-US)
  - WebAssembly.RuntimeError

### eval
- 第三方代码可以看到 eval() 被调用时的作用域，可能导致不同方式的攻击
```js
// 慢，浏览器需要全局查询 Date 变量
// 立刻执行
eval('console.log(Date.now())');
// 只需查询全局和函数体内的变量
// 返回的是函数,调用后才开始执行
(Function('console.log(Date.now())'))();
```

### isFinite
- 是否为有限数值
```js
isFinite(Infinity); // false
isFinite(NaN); // false
isFinite(2e64); // true
// 会自动转化
isFinite(null); // true
Number.isFinite(null); // false 可靠检测
```

### isNaN
- 是否为 NaN
- 怪异行为：如果 isNaN 函数的参数不是 Number 类型，isNaN 函数会首先尝试将这个参数转换为数值，再判断
```js
isNaN('hello'); // true
Number.isNaN('hello'); // false 可靠检测
// isNaN 的polyfill 可理解为
var isNaN = function (value) {
  var n = Number(value);
  return n !== n;
}
// 怪异行为的利用
function add(x) {
  if (isNaN(x)) x = 0;
  return x + 1;
}
function add(x) {
  if (Number.isNaN(Number(x))) x = 0;
  return x + 1;
}
```

### parseFloat
- 解析成浮点数

### parseInt
- 解析成整数,向下取整(floor)
```js
parseInt('0xF'); // 15
parseInt('F', 16); // 15
parseInt('015', 10); // 10
parseInt('435', 2); // NaN
// 严格解析函数
function filterInt (value) {
  return (/^(\-|\+)?([0-9]+|Infinity)$/.test(value)) ? Number(value) : NaN;
}
// 判断一个变量是否是整数
x % 1 === 0 ? '是' : '不'
parseInt(x) === x ? '是' : '不'
```

### decodeURI
- 包含无效字符序列，会引发 URIError 异常

### decodeURIComponent
- 包含无效字符序列，会引发 URIError 异常

### encodeURI
- 不转义的字符 `[A-Za-z0-9-_.!~*'()]#;,/?:@&=+$`
- 其余 UTF-8 转义
```js
encodeURI('http://example.com/?s=王');
// http://example.com/?s=%E7%8E%8B
```

### encodeURIComponent
- 不转义的字符 `[A-Za-z0-9-_.!~*'()]`
- 其余 UTF-8 转义
```js
encodeURIComponent('http://example.com/?s=王');
// http%3A%2F%2Fexample.com%2F%3Fs%3D%E7%8E%8B
```

### Object
- 构造函数：为给定值创建一个对象包装器
- 以非构造函数形式调用时，Object 的行为等同于 new Object()
  ```js
  new Object(true); // 等价于 new Boolean(true);
  ```
- Object.defineProperty 给对象添加一个属性
- Object.defineProperties 给对象添加多个属性
- Object.getOwnPropertyDescriptor (自身可枚举 + 自身不可枚举)
- Object.getOwnPropertyDescriptors (自身可枚举 + 自身不可枚举)
  - 使用一些内部特性来描述属性的特征,开发者不能直接访问这些特性
  - 为了将某个特性标识为内部特性,规范会用两个中括号把特性的名称括起来,`[[Enumeralbel]]`
  - 1.数据属性: 包含一个保存数据值,值会从这个位置读取,也会写入这个位置.有4个特性描述它的行为
    - `[[Configurable]]` 是否可 delete删除并重新定义; 修改它的特性; 改为数据属性; 默认 true / false(define设置)
    - `[[Enumerable]]` 是否可 for-in循环返回. 默认 true / false(define设置)
    - `[[Writable]]` 属性值是否可被修改. 默认 true / false(define设置)
    - `[[Value]]` 属性直接的值. 默认 undefined
  - 2.访问器属性: 不包含数据值,包含一个获取(getter)函数和设置(setter)函数.有4个特性描述它的行为
    - `[[Configurable]]` 是否可 delete删除并重新定义; 修改它的特性; 改为数据属性; 默认 true / false(define设置)
    - `[[Enumerable]]` 是否可 for-in循环返回. 默认 true / false(define设置)
    - `[[Get]]` 获取函数,读取属性时调用. 默认 undefined
    - `[[Set]]` 设置函数,写入属性时调用. 默认 undefined
  ```js
  const obj = {a: 1};
  Object.defineProperties(obj, {
    // 数据属性
    b: {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 2,
    },
    // 访问器属性
    c: {
      configurable: false,
      enumerable: false,
      get: function() { return this.a * 2 },
      set: function(v) { this.a = v / 2 },
    },
  });
  Object.getOwnPropertyDescriptor(obj, 'c');
  Object.getOwnPropertyDescriptors(obj);
  ```
- Object.create 指定原型对象和属性创建一个新对象
  ```js
  const obj1 = {a: 1};
  const obj2 = Object.create(obj1, {b: { value: 2 }});
  // console.log(obj2);
  // b: 2
  // __proto__:
  //   a: 1
  //   __proto__:
  Object.getPrototypeOf(obj2) === obj1 // true

  // 实现 Object.create
  Object.create1 = (o, properties = {}) => {
    const objNew = {};
    Object.setPrototypeOf(objNew, o); // objNew.__proto__ = obj;
    Object.defineProperties(objNew, properties);
    return objNew;
  };
  Object.create1({a: 1}, {b: {value: 2}});
  ```
- Object.assign 通过复制一个或多个对象来创建一个新对象
  - assign方法接收多个源对象中 可枚举(obj1.b.propertyIsEnumerable() = true) && 自有(obj1.hasOwnProperty('a') = true) 的属性复制到到目标对象
  - 如果赋值期间出错,则操作会中止并退出,不会回滚之前的赋值
    ```js
    const obj1 = {
      set a(x) { console.log(x); } // 1
    };
    let obj2;
    try {
      obj2 = Object.assign(obj1, {a: 1}, {
        b: 2,
        get c() { throw new Error(); }
      });
    } catch (e) {
      console.log(e); // Error at Object.get c
      console.log('----');
      console.log(obj1); // {b: 2, set a: f}
      console.log('----');
      console.log(obj2); // undefined
    }
    ```
- Object.is 比较两个值是否相同，所有NaN值都相等(与 == 和 === 不同)
  - 为了改善 === 操作符判断的问题
  ```js
  +0 === -0; // true
  +0 === 0; // true
  -0 === 0; // true
  Object.is(+0, -0); // false
  Object.is(+0, 0); // true
  Object.is(-0, 0); // false
  NaN === NaN; // false
  Object.is(NaN, NaN); // true
  ```
- Object.entries (自身可枚举)
  - Object.fromEntries 相反方法
  ```js
  const obj = {a: 1, b: {c: 3}};
  const obj1 = Object.entries(obj);
  const obj2 = Object.fromEntries(obj1);
  JSON.stringify(obj) === JSON.stringify(obj2); // true
  ```
- Object.freeze 冻结对象，其它代码不能删除或更改任何属性
- Object.getOwnPropertyNames (自身可枚举 + 自身不可枚举)
- Object.getOwnPropertySymbols (自身可枚举 + 自身不可枚举)
- Object.isExtensible 判断对象是否可扩展
- Object.isFrozen 判断对象是否已经冻结
- Object.isSealed 判断对象是否已经密封
- Object.keys (自身可枚举)(数组的key会变成字符串)
- Object.preventExtensions 防止对象的任何扩展
- Object.seal 防止其它代码删除对象的属性
- Object.values 返回一个数组，包含自身可枚举的值
- Object.prototype.hasOwnProperty 返回一个布尔值，表示对象自身是否含有指定属性
- Object.prototype.toString
- Object.prototype.valueOf 返回指定对象的原始值
- 原型相关
  - Object.getPrototypeOf 返回指定对象的原型对象
    ```js
    Object.getPrototypeOf([]) // [].__proto__
    Object.getPrototypeOf(Array) === Function.prototype // true
    ```
  - Object.setPrototypeOf 设置对象的原型
    ```js
    const obj1 = {a: 1};
    const obj2 = {b: 2};
    Object.setPrototypeOf(obj1, obj2);
    obj1.__proto__ === obj2; // true
    ```
  - Object.prototype.isPrototypeof 返回一个布尔值，表示对象是否在原型链中
    ```js
    Array.prototype.isPrototypeOf([]) // [].__proto__ -> Array.prototype
    ```
- 增强的对象语法 - 简写方法名
  ```js
  let key1 = 'key1';
  let obj = {
    // 函数表达式命名
    f1: function() {},
    key1: function() {},
    // 新的简写语法
    f2() {},
    [key1]() {},
    // 获取函数与设置函数
    _name: '王二',
    get name() {return this._name;},
    set name(name) { this._name = name; },
  };
  ```
- 对象解构 - 使用与对象匹配的结构来实现对象属性赋值
  - 解构赋值不一定与对象的属性匹配
  - 想让变量直接使用属性的名称,可以使用简写语法
  - 可以在解构赋值的同时定义默认值
  - 解构赋值可使用嵌套结构,以匹配嵌套的属性
  ```js
  let obj = {a: 1, b: 2, c: 3, g: {h: 123}};
  let {a: a1, b, d = 4, g: { h: h1 }} = obj;
  console.log({a1, b, d, h1});
  // 参数上下文匹配
  function f1(t1, {a: a1, b, d = 4, g: { h: h1 }} = {}) {
    console.log({a1, b, d, h1});
  }
  f1(1);
  ```
- 遍历属性 - 参见：img/遍历属性函数
- 判断属性是否存在
  1. obj.hasOwnProperty (自身)
  2. 'a' in obj (只要能访问到)
- 删除属性
  1. delete obj.a

### Function

### Boolean

### Symbol

### Error
```js
function f1() {
  try {
    throw new TypeError('这是错误的内容了');
    return 1;
  } catch (e) {
    console.log(e instanceof TypeError);
    console.log(e.message);
    return 2;
  } finally {
    console.log('ok');
    return 3;
  }
}
f1(); // 3
```
- 错误类型
  - InternalError 底层JS引擎抛出异常时由浏览器抛出(例:递归过多导致栈溢出)
  - EvalError 使用eval函数发生异常时抛出,基本上,只要不把eval当成函数调用就会报告该错误
  - SyntaxError 语法错误 🔥
    - `function = 3` // Uncaught SyntaxError: Unexpected token '='
  - RangeError 范围错误 🔥 数值越界时抛出(例:定义数组时设置了不支持的长度,-20或Number.MAX_VALUE)
    - `function f1() { f1(); } f1();` // Uncaught RangeError: Maximum call stack size exceeded
  - ReferenceError 找不到对象时发生 🔥
    - `a['a'] = 12;` // Uncaught ReferenceError: a is not defined
  - TypeError 类型错误 🔥 变量不是预期的类型或访问不存在的方法
    - `let a = {}; a.run();` // Uncaught TypeError: a.run is not a function
  - URIError 使用 encodeURI() 或 decodeURI() 传入了格式错误的URI时发生
- 抛出错误
  - throw 操作符,用于在任何时候抛出自定义错误,必须有一个值,但值的类型不限
    - throw 123; throw 'hello'; throw true; throw {name: 'GO'};
    - 使用throw操作符时,代码立即停止执行
  - 可以通过内置的错误类型来模拟浏览器错误
    - throw new Error('Bad');
    - throw new URIError('Bad');
- 自定义的错误类型
  - 可以通过继承 Error 可以创建自定义的错误类型
- error事件
  - 任何没有被 try/catch 语句捕获的错误都会在window对象上触发error事件
  ```js
  window.onerror = (message, url, line) => {
    console.log({ message, url, line});
  };
  window.addEventListener('error', function({ message, filename: url, lineno: line}) {
    console.log({ message, url, line});
  });
  throw new Error('这是错误了');
  ```
- 静态代码分析器
  - 通过在构建流程中添加静态代码分析或代码检查器(linter),可以预先发现非常多错误
  - 常见的静态分析工具是 JSHint、JSLint、Google Closure、TypeScript
- 使用 debugger 关键字
  - 在运行碰到这个关键字时,所有主流浏览器都会打开开发者控制面板,并显示断点

### Number
- n.toString(进制)
- n.toFixed(小数位) 四舍五入
- n.toExponential(小数位) 科学计数形式
- Number.isInteger(12.00) // true

### BigInt

### Math对象
- Math.E 自然对数的基数e的值
- Math.LN2 2为底的自然对数
- Math.LN10 10为底的自然对数
- Math.LOG2E 以2为底e的对数
- Math.LOG10E 以10为底e的对数
- Math.PI π的值
- Math.SQRT1_2 1/2的平方根
- Math.SQRT2: 2的平方根
- Math.max
- Math.min
- Math.floor 向下取整
- Math.ceil 向上取整
- Math.round 四舍五入
- Math.fround 最接近的单精度(32位)浮点值表示
- Math.random
- Math.abs
- Math.exp(x) Math.E的x次幂
- Math.log(x) x的自然对数
- Math.pow(x, power) x的power次幂

### Date
- `Date.parse('2021-04-09T00:00:00.888')` 返回时间戳: 2021-04-09 00:00:00`
- `Date.UTC(2021, 3, 9, 0, 0, 0, 888)` 返回时间戳: 2021-04-09 08:00:00
- `Date.now()` 返回当前时间戳
- `const d1 = new Date(2021, 3, 9, 0, 0, 0, 888)` 2021-04-09 00:00:00
  - `new Date('2021-07-07 13:50:07')`
  - `new Date(1625637007000)`
- `Date.prototype.toString()` 返回日期的字符串表示
  - `Date.prototype.valueOf()` 返回日期的时间戳
  - `Date.prototype.getTime()` 返回日期的时间戳
- `Date.prototype.toISOString()` 返回 2021-04-09T07:02:39.355Z
- `Date.prototype.getTimezoneOffset()` 分钟计的UTC与本地时间的偏移量 -480

### String
- `s.length` 属性
- `String.fromCharCode(int)` ES5提供 String.fromCharCode() 无法正确识别码点大于 0xFFFF 的字符
- `String.fromCodePoint(int)` ES6的这个可以:Unicode码点->对应字符
- `String.raw`\u00A9` 还原模版字符串的处理方法
- `String.prototype.length` 按照16位,2B编码,大于2B,长度2
- `String.prototype.charAt(index)` 字符串指定索引(`0~length-1`)处的字符
- `String.prototype.charCodeAt(index)` 字符串指定索引(`0~length-1`)处的UTF-16编码单元体现的数字，范围 `0~65536`，`0x0000~0xffff`
- `String.prototype.codePointAt(index)` 字符串指定索引(`0~length-1`)处的编码单元体现的数字
- `String.prototype.indexOf(str)` `lastIndexOf(str)` 指定子串开始/结束的位置
- `String.prototype.concat(str)` 字符串拼接
- `String.prototype.split(str)` 字符串分割成数组
- `String.prototype.slice(beginIndex, endIndex)` 返回字符串切割的一部分(支持负值)
- `String.prototype.substring(indexStart, indexEnd)`
- `String.prototype.substr(indexStart, length)`
- `String.prototype.match` `replace` `search`
- `String.prototype.normalize(form)` 按照指定一种 Unicode 正规形式将字符串正规化
- `String.prototype.toUpperCase()` `toLowerCase()`
- `String.prototype.repeat(count)` 重复指定次数
- `String.prototype.trim()` 去除开头结尾的空白字符
  - `String.prototype.trimStart()` 去除开头的空白字符
  - `String.prototype.trimEnd()` 去除结尾的空白字符
- `String.prototype.popStart()` 头部补全 `'123'.padStart(8, 'abc') === 'abcab123'`
- `String.prototype.popEnd()` 尾部补全
- `String.prototype.includes()` 字符串搜索方法, 都支持第二个参数(开始搜索的位置)
- `String.prototype.startsWith()` 字符串搜索方法, 都支持第二个参数(开始搜索的位置)
- `String.prototype.endsWith()` 字符串搜索方法, 都支持第二个参数(开始搜索的位置)
- 新增了几个专门处理4字节码点的函数
  - `String.fromCodePoint()` Unicode码点->对应字符
  - `String.prototype.codePointAt()` 字符->对应的码点

### RegExp
- 通过 RegExp 类型支持正则表达式, 使用类似 Perl 的简洁语法来创建
  - `let r1 = /^.$/u;` */pattern/flags*
  - `let r1 = new RegExp('.', 'u');`
  - pattern(模式)可以是任何简单或复杂的正则表达式
  - 可以携带0个或多个 flags(标记),用于控制正则表达式的行为
  - 实例:
    ```js
    let s = '<a href="https://www.baidu.com/">王热砂</a>';
    console.log(s.match(/<a href="[^"]*">([^<]*)<\/a>/));
    ```
- 匹配模式的flags(标记)
  - g:全局模式 - 表示查找字符串的全部内容,而不是找到第一个匹配的内容就结束
  - i:不区分大小写 - 表示在超找匹配时忽略 pattern 和 字符串 的大小写
  - m:多行模式 - 表示查找到一行文本末尾时会继续查找
  - y:粘附模式 - 表示只查找从 lastIndex 开始及之后的字符串
  - u:Unicode模式 - 用来处理大于 \uFFFF 的Unicode 字符 `/\u{20BB7}/u.test('𠮷')`
  - s:dotAll模式 - 表示元字符.匹配任何字符(包括\n或\r)
- RegExp实例属性
  - r.global 布尔值，表示是否设置了 g 标记
  - r.ignoreCase 布尔值，表示是否设置了 i 标记
  - r.multiline 布尔值，表示是否设置了 m 标记
  - r.sticky 布尔值，表示是否设置了 y 标记
  - r.unicode 布尔值，表示是否设置了 u 标记
  - r.dotAll 布尔值，表示是否设置了 s 标记
  - r.lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始
  - r.source 实例的pattern,没有开头和结尾的斜杠
  - r.flags 实例的flags(标记)
- RegExp实例方法
  - r.exec()
    ```js
    let s = 'Hello,red! Hello,blue!';
    // 不用g的话,index始终是0
    let r = /Hello,([a-z]*)!/g;
    let res = r.exec(s);
    // 0: "Hello,red!" 1: "red" groups: undefined index: 0 input: "Hello,red! Hello,blue!"
    res = r.exec(s);
    // 0: "Hello,blue!" 1: "blue" groups: undefined index: 11 input: "Hello,red! Hello,blue!" length: 2
    res = r.exec(s);
    // null
    ```
  - r.test() 判断输入文本与模式是否匹配
- RegExp构造函数属性
  - 这些属性适用于作用域中的所有正则表达式,且会根据最后执行的正则表达式操作而变化
  - 可以通过2种不同的方式访问它们
  - RegExp.input, RegExp.$_ 最后搜索的字符串(非标准)
  - RegExp.lastMatch, RegExp.$& 最后匹配的文本
  - RegExp.lastParen, RegExp.$+ 最后匹配的捕获组(非标准)
  - RegExp.leftContext, RegExp.$` input字符串中出现在 lastMatch 前面的文本
  - RegExp.rightContext, RegExp.$' input字符串中出现在 lastMatch 后面的文本
  ```js
  /(.hort)/g.test('a short summer');
  console.log([
    RegExp.input, RegExp.$_, // "a short summer"
    RegExp.lastMatch, RegExp['$&'], // "short"
    RegExp.lastParen, RegExp['$+'], // "short"
    RegExp.leftContext, RegExp['$`'], // "a "
    RegExp.rightContext, RegExp['$\''], // " summer"
  ]);
  ```
- 字符串的正则方法(match、replace、search、split)
  - ES6将这四个方法,在语言内全部调用 RegExp 的实例方法,做到与正则相关的方法,都定义在RegExp对象上
  - String.prototype.math 调用 RegExp.prototype[Symbol.match]
  - String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
  - String.prototype.search 调用 RegExp.prototype[Symbol.search]
  - String.prototype.split 调用 RegExp.prototype[Symbol.split]
  ```js
  'abc'.replace({
    [Symbol.replace](searchVal, replaceVal) {
      return searchVal.replace('ab', replaceVal);
    }
  }, 'k'); // kc
  ```
- 命名捕获组
  ```js
  /(\d+)-(\d+)-(\d+)/.exec('2019-03-23');
  /(?<year>\d+)-(?<month>\d+)-(?<day>\d+)/.exec('2019-03-23');
  ```
- 匹配字符
  - `\`
    - 1.`\特殊字符` 表示转义,下一个字符应该按字面理解;
      - `string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")` // $&表示整个被匹配的字符串
    - 2.`\非特殊字符` 不能按字面理解
  - `^` 匹配输入的开始位置.
    - 如果多行标志被设置为 true, 那么也匹配换行符后紧跟的位置 Demo `/^abc/`
  - `$` 匹配输入的结束位置.
    - 如果多行标志被设置为 true, 那么也匹配换行符前的位置 Demo `/abc$/`
  - `*` 匹配前一个表达式0～n次. 等价于 `{0,}` Demo `/ab*c/`
  - `+` 匹配前一个表达式1～n次. 等价于 `{1,}` Demo: `/(ab)+c/.test('ababc')`
  - `?` 匹配前一个表达式0或1次. 等价于 `{0,1}` Demo: `/(ab)?c/.test('abc')`
    - 若紧跟在任何量词 `*、+、?、{}` 后面，将会使量词变为非贪婪(匹配尽量少的字符), 和缺省使用的贪婪模式相反
  - `.` 匹配除换行符(比如:`\n` `\r` 非BMP字符)之外的任何单个字符串
    - 如果 `s(dotAll)` 标志位被设为 true, 它也会匹配换行符
      ```js
      const s = `hello
      world
      `;
      /hello.world/.test(s); // false
      /hello.world/s.test(s); // true
      ```
  - `(x)` 匹配 x 并记住匹配项. 其中括号称为捕获括号.
    - `/(lo|ld)/.exec('Hello World!')` 匹配一个
    - `[...'Hello World!'.match(/(lo|ld)/g)]` 匹配一个
    - `[...'Hello World!'.matchAll(/(lo|ld)/g)]` 匹配所有
    - `'Hello World!'.replace(/(lo|ld)/g, '-$1')` 替换所有
  - `(?:x)` 匹配 x 但是不记住匹配项. 这种括号称为非捕获括号.
  - 环视(不占用字符，只匹配字符所在的位置)
    - `x(?=y)` 肯定顺序环视，匹配x,仅当x后面是y
      ```js
      '123123'.replace(/(?=3)/g, 'A'); // 12A312A3
      '1234567'.replace(/(?=(\d{3})+$)/g, ','); // 1,234,567
      ```
    - `(?<=y)x` 肯定逆向环视，匹配x,仅当x前面是y
    - `x(?!y)` 正向否定查找. 仅当x后面不紧跟y时匹配x
    - `(?<!y)x` 反向否定查找. 仅当x前面不是y时匹配x
  - `x|y` 匹配x或y
  - `{n}` `{n,}` `{n,m}` 匹配前一个字符n～m次
  - `[xyz]` 匹配方括号中的任意字符，包括转义序列.
    - 可以使用破折号 `-` 来指定一个字符范围
    - 对于 `.、*` 这样的特殊符号无需转义
  - `[^xyz]` 匹配任何没有包含在方括号中的字符
  - `[\b]` 匹配一个退格(U+0008)
  - `\b` 匹配一个词的边界. 一个词的边界就是一个词不被另一个字符跟随的位置 `/hello\b/i.exec('Hello world')`
  - `\B` 匹配一个非单词边界. `/hell\B/i.exec('Hello world')`
  - `\cX` 当X是处于A到Z之间的字符的时候, 匹配字符串中的一个控制符 EG: `/\cM/ 匹配 contrl-M(U+000D)`
  - `\d` 匹配一个数字字符. 等价于 [0-9]
  - `\D` 匹配一个非数字字符. 等价于 [^0-9]
  - `\f` 匹配一个换页符(U+000C)
  - `\n` 匹配一个换行符(U+000A)
  - `\r` 匹配一个回车符(U+000D)
  - `\s` 匹配一个空白字符(包含 空格、制表符、换页符、换行符)
  - `\S` 匹配一个非空白字符
  - `\t` 匹配一个水平制表符(U+0009)
  - `\v` 匹配一个垂直制表符(U+000B)
  - `\w` 匹配一个单字字符(字母、数字、下划线). 等价于 `[A-Za-z0-9_]`
  - `\W` 匹配一个非单字字符. 等价于 `[A-Za-z0-9_]`
  - `\n` ???
  - `\0` 匹配 NULL(U+0000) 字符, 不要在这后面跟其它小数, 因为 `\0<digits>` 是一个八进制转义序列
  - `\xhh` 匹配一个两位十六进制数 (\x00-\xFF) 表示的字符
  - `\uhhhh` 匹配一个四位十六进制数表示的 UTF-16 代码单元
  - `\u{hhhh} 或 \u{hhhhh}` 匹配一个十六进制数表示的 Unicode字符
- 实例
  - 中国手机号 `/^((13[0-9]{1})|159|153)+\d{8}$/`
  - 电话号码 `/^((\d{3,4}[-| |+]){0,1})\d{7,8}$/`
  - 邮箱 `/^xxx@xxx\.[a-zA-Z]{2,3}$/` `([a-zA-Z0-9]+[_|.])*[a-zA-Z0-9]+`
### Array
- 创建数组的几种方式
  - 1.构造函数 `var arr = new Array()`
  - 2.字面量 `var arr = [1,2,3]`
- 对象原型属性与方法
  - `Array.prototype.length` 修改length会影响数组的长度
  - `Array.prototype.toString()` 返回数组中每个值的等效字符串拼接成的一个逗号分隔的字符串
    ```js
    [['a', 'b'], 'c'].toString() // "a,b,c"
    ```
  - `Array.prototype.join(separator=',')` 连接成字符串,返回操作后的字符串
    - arr.toString() 也能做到
  - 操作方法
    - `Array.prototype.concat(...arr)` 合并,返回操作后的数组
      - Symbol.isConcatSpreadable 控制合并的时候是否打平/展开
    - `Array.prototype.slice(star, end)` 从数组中提取片段,返回数组片段
    - `Array.prototype.splice(index, countRemove[, ...ele])` 从数组中移除一些元素,并替换它们
  - 栈方法(LIFO后进先出)
    - `Array.prototype.push(...ele)` 末尾添加多个元素,返回操作后的长度
    - `Array.prototype.pop()` 末尾移除1个元素,返回该元素
  - 队列方法(FIFO先进先出)
    - `Array.prototype.push(...ele)` 末尾添加多个元素,返回操作后的长度
    - `Array.prototype.shift()` 头部移除1个元素,返回该元素
  - `Array.prototype.unshift(...ele)` 头部添加多个元素,返回操作后的长度
  - 搜索位置方法
    - `Array.prototype.indexOf(ele[, fromIndex])` 返回元素的索引
    - `Array.prototype.lastIndexOf(ele[, fromIndex])` 返回元素的索引,从结尾开始搜索
    - `Array.prototype.find()` 找出第一个符合条件的数组成员 // es6
    - `Array.prototype.findIndex()` 找出第一个符合条件的数组key // es6
    ```js
    const arr = ['a', 'b', 'c'];
    console.log(arr.find((val, index, obj) => {
      return false;
    }))
    ```
  - 排序方法(都返回调用它们数组的引用)
    - `Array.prototype.reverse()` 颠倒数组的顺序
    - `Array.prototype.sort(fn)` 数组排序,默认升序
      ```js
      const arr = [1, 2, 9, 4, 6];
      arr.sort((a, b) => b - a);
      ```
  - 复制、填充
    - `Array.prototype.fill()` 填充数组 // es6
      ```js
      let arr = Array(6); // [empty × 6]
      arr.fill(0); // [0, 0, 0, 0, 0, 0]
      arr.fill(1, 3); // [0, 0, 0, 1, 1, 1]
      arr.fill(2, 2, -2); // [0, 0, 2, 2, 1, 1]
      ```
    - `Array.prototype.copyWithin()` 复制替换 // es6
      ```js
      let arr = [1, 2, 3, 4, 5, 6];
      arr.copyWithin(3); // [1, 2, 3, 1, 2, 3]
      arr.copyWithin(4, 2); // [1, 2, 3, 1, 3, 1]
      ```
  - 遍历方法
    - `Array.prototype.entries()` // 遍历数组,[[k, v], [k, v]]
    - `Array.prototype.keys()` // 遍历数组 [k, k]
    - `Array.prototype.values()` // 遍历数组 [v, v]
  - 迭代方法
    - `Array.prototype.forEach(callback[, thisObject])` 在数组每个元素上执行callback
    - `Array.prototype.map(function(currentValue,index,arr), thisValue)` 遍历数组,callback对数组进行操作,并将结果写回数组
    - `Array.prototype.filter(callback[, thisObject])` 遍历数组,符合条件的返回true
    - `Array.prototype.every(callback[, thisObject])` 遍历数组,每项都返回true,则返回true
    - `Array.prototype.some(callback[, thisObject])` 遍历数组,有1项返回true,则返回true
  - 归并方法
    - `Array.prototype.reduce(callback[, thisObject])` 遍历数组, callback(firstVal, secondVal), 初始值, 返回总和
    - `Array.prototype.reduceRight(callback[, thisObject])` 右侧开始遍历
  - `Array.prototype.includes()` // 判断是否包含某给定值
  - `Array.prototype.flat(Infinity)` // 将嵌套的数组拉平,变成一维数组
    - 扁平化数组(1.递归;2.栈)
  - `Array.prototype.flatMap()` // 拉平遍历
- 构造函数静态方法
  - `Array.isArray()` 见：<3种判断数组的方法，介绍区别与优劣>
  - `Array.from()` 用于将2类对象转换为真正的数组
    - 1.类似数组的对象(array-like object)
    - 2.可遍历(iterable)的对象 (包括 Set 和 Map)
      ```js
      function f1() { console.log(Array.prototype.slice.call(arguments)); } f1(1, 2, 3);
      Array.from(arguments);
      Array.from('123456', function (v) { return v * this.cap }, { cap: 2 }); // [2, 4, 6, 8, 10, 12]
      const map1 = new Map(); map1.set('a', '1'); map1.set('b', '2');
      Array.form(map1); // [["a","1"],["b","2"]]
      ```
  - `Array.of()` 用于将一组值转换为数组
    ```js
    Array.of(1, 2, 3); // [1, 2, 3]
    ```
- 扩展运算符
  - 替代函数的apply方法
    - 由于扩展运算符可以展开数组,所以不再需要apply方法,将数组转换为参数了
    - function f(x, y) {}; f.apply(null, [1, 2]); // es5
    - function f(x, y) {}; f(...[1, 2]); // es6
  - 实现了 Iterator 接口的对象
    - *任何定了遍历器(Iterator)接口的对象,都可以用扩展运算符转换为真正的数组*
    ```js
    let a = {};
    a[Symbol.iterator] = function*(){
      for (let i = 1; i <= 3; i++) yield i;
    };
    [...a]
    ```
  - 合并2个数组
    ```js
    a.concat(b)
    for (const v of b) { a.push(v); }
    [...a, ...b] // es
    a.push(...b) // es
    Array.prototype.push.apply(a, b) // es
    ```
  - 复制数组
    ```js
    let b = a.concat()
    let b = [...a]
    let [...b] = a
    ```
  - 字符串长度
    - `[...'hello😄'].length` // 可以正确识别四个字节的unicode字符
    - 同 `Array.from('hell😄').length`
- 数组空位
  ```js
  Array.from(new Array(3)) // [undefined, undefined, undefined]
  Array.from([,,,]) // [undefined, undefined, undefined]
  ```
- 数组索引
  - 修改数组 `arr[100] = 1`,会自动修改数组的长度
  - 数组 length 属性是可以修改的,修改后,可直接改变数组的长度
- 已知如下数组，编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
  ```js
  var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
  Array.from(new Set(arr.toString().split(',')), v => Number(v)).sort((a, b) => b - a);
  [...new Set(arr.flat(Infinity))].sort((a, b) => b - a);
  ```
- map和forEach的区别：map可以修改后返回新的数组

### 定型数组
- ArrayBuffer / SharedArrayBuffer
- DataView
- Int8Array / Uint8Array / Uint8ClampedArray
- Int16Array / Uint16Array
- Int32Array / Uint32Array
- Float32Array / Float64Array
- BigInt64Array / BigUint64Array
- 定型数组(typed array)是 ECMAScript 新增的结构,目的是提升向原生库传输数据的效率
- 2006年浏览器提供商期待开发一套 JS API,从而重复利用 3D图形API 和 GPU加速,以便在 canvas 元素上渲染复杂的图形
- 2011年发布 WebGL,因为 JS 数组与原生数组之间不匹配,出现了性能问题
- 为解决这个问题,实现了 CanvasFloatArray,最后变成了 Float32Array,也就是今天定型数组中可用的第一个类型
- `Float32Array` 是一种视图,允许js运行时访问一块名为 ArrayBuffer 的预分配内存
- ArrayBuffer
  - 是所有定型数组及视图引用的基本单位
  - SharedArrayBuffer 是 ArrayBuffer 的一个变体,可以无需复制就在执行上下文间传递它
  - ArrayBuffer 一经创建就不能调整大小,类似于 C++ 的 malloc()
  ```js
  // 申请4个字节的内存
  const b1 = new ArrayBuffer(4);
  // 00000000 00000000 00000000 00000000
  ```
- DataView - 第一种允许读写 ArrayBuffer 的视图
  - 专为 文件I/O 和 网络I/O 设计,其API支持对缓冲数据的高度控制,但性能要差些
  - DataView 使用 ElementType 来实现 JS 的 Number 类型到缓冲内二进制格式的转换
  - ElementType
    - Int8 / 1字节 / 8位有符号整数 / C: signed char / -128~127
    - Uint8 / 1字节 / 8位无符号整数 / C: unsigned char / 0~255
    - Int16 / 2字节 / 16位有符号整数 / C: short
    - Uint16 / 2字节 / 16位无符号整数 / C: unsigned short
    - Int32 / 4字节 / 32位有符号整数 / C: int
    - Uint32 / 4字节 / 32位无符号整数 / C: unsigend int
    - Float32 / 4字节 / 32位 IEEE-754浮点数 float
    - Float64 / 8字节 / 64位 IEEE-754浮点数 double
  - 字节序 - 计算机系统维护的一种字节顺序的约定
    - DataView 只支持2种约定: 大端字节序 和 小端字节序
    - 大端字节序也称为 "网络字节序",从最后一个字节往前读
    - 小端字节序,从第一个字节往后读
  ```js
  // 00000000 00000000 00000000 00000000
  const view1 = new DataView(b1, 2);
  // 00000000 00000000 00000001 10010000
  view1.setInt16(0, 400);
  // 00000000 00000000 00000001 01111110
  view1.setInt8(1, 126);

  // 大端字节序读取  parseInt('00000001 01111110', 2)
  view1.getInt16(0); // 382
  // 小端字节序读取: parseInt('01111110 00000001', 2)
  view1.getInt16(0, true); // 32257
  ```
- 定型数组 - 另一种形式的视图
  - 定型数组与DataView的区别在于,它特定于一种 ElementType 且 遵循系统原生的字节序
  ```js
  // 定型数组
  const int1 = new Int8Array(b1);

  // 00000000 00000000 00000000
  const int2 = new Int8Array(3);

  // 00000000 00000000 00000000 00000000
  let int3 = new Uint8Array([0, 0, 0, 0]);
  // 11111111 11111111 11111111 11111111
  int3 = int3.map(x => 2**8 - 1);

  // 11111111 11111111 11111111 11111111
  let int4 = Uint8Array.of(255, 255, 255, 255);
  // 11111111 00000001 00000001 00000002
  int4.set(Uint16Array.of(1, 1, 2), 1);

  // 00000001 00000001
  const int5 = int4.subarray(1, 3);
  ```

### Map - 映射
- ES6之前,JS中 "键/值" 存储可以使用 Object 方便高效地完成
- Map的键名的范围不限于字符串,各种类型的值(包括对象)都可以当作键名,是一种更完善的 Hash 结构实现
  ```js
  // {"a" => "123", "b" => "456", "c" => "678"}
  new Map([
    ['a', '123'],
    ['b', '456'],
  ]).set('c', '678');
  // {"a" => "123", "b" => "456"}
  new Map({
    [Symbol.iterator]: function*() {
      yield ['a', '123'];
      yield ['b', '456'];
    }
  });
  ```
- Map的实例属性和方法
  - Map.prototype.size: 返回成员总数
  - Map.prototype.set(): 设置键值
  - Map.prototype.get(): 获取键值
  - Map.prototype.has(): 某个键是否在Map对象中
  - Map.prototype.delete(): 删除某个键
  - Map.prototype.clear(): 清除所有成员
  - 遍历方法
    - *Map的遍历顺序就是插入顺序*
    - Map.prototype.keys(): 返回键名的遍历器
    - Map.prototype.values(): 返回键值的遍历器
    - Map.prototype.entries(): 返回所有成员的遍历器,等于 `map1[Symbol.iterator]`
    - Map.prototype.forEach(): 遍历所有成员

### WeakMap - 弱映射
- WeakMap与Map类似,但与Map有2个区别：
  - 1.WeakMap只接受对象作为键名(null除外)
  - 2.WeakMap的键名指向的对象,不计入垃圾回收机制(*弱引用的只是键名,键值仍然正常引用*)
    - WeakMap 中 "weak" 表示弱映射的键是 "弱弱的拿着"
- WeakMap的设计目的: 有时我们想在某个对象上存放一些数据, 但这会形成对对象对引用
  ```js
  // 已回收obj
  let obj = { a: 123 };
  const wmap1 = new WeakMap();
  wmap1.set(obj, [1, 2, 3]);
  obj = null;

  // 未回收obj
  let obj = { a: 123 };
  const wmap1 = new Map();
  wmap1.set(obj, [1, 2, 3]);
  obj = null;
  ```

### Set - 集合
- 类似于数组,但成员的值都是唯一的,没有重复的值
- Set函数可以接受一个数组(或具有 iterable 接口的其它数据结构) 作为参数,用来初始化
- 通过 add() 方法向Set结构加入成员,Set结构不会添加重复的值
  ```js
  // {"a", "b"}
  new Set({
    [Symbol.iterator]: function*() {
      yield 'a';
      yield 'b';
    }
  });
  // {1, 2, 3}
  new Set([1, 2]).add(2).add(3);
  ```
- 判重依据
  - 向 Set 加入值的时候,不会发送类型转换,所以5和"5"是2个不同的值
  - Set内部使用"Same-value-zero equality"判断两个值是否相同,类似于精确相等运算符(===)
  - 主要区别: NaN === NaN // false, Set则认为相等
- Set实例的属性和方法
  - Set.prototype.size: 返回Set实例的成员总数
  - 操作方法
    - Set.prototype.add(): 添加某个值
    - Set.prototype.delete(): 删除某个值
    - Set.prototype.has(): 该值是否为Set的成员
    - Set.prototype.clear(): 清除所有成员
  - 遍历方法
    - *由于Set结构没有键名,只有键值(或者说键名和键值是同一个值),keys和values方法的行为完全一致*
    - Set.prototype.keys(): 返回键名的遍历器
    - Set.prototype.values(): 返回键值的遍历器
    - Set.prototype.entries(): 返回键值对的遍历器
    - Set.prototype.forEach(): 使用回调函数遍历每个成员

### WeakSet - 弱集合
- WeakSet结构与Set类似,但与Set有2个区别:
  - 1.WeakSet的成员只能是对象,不能是其它类型的值
  - 2.WeakSet中的对象都是弱引用,即垃圾回收机制不考虑 WeakSet 对该对象的引用
- *垃圾回收机制何时运行是不可预测的,因此es6规定WeakSet不可遍历*
- *WeakSet的一个用处,是存储DOM节点,而不用担心这些节点从文档移除时,会引发内存泄露*

### JSON
- JSON(JavaScript Object Notation,JS对象标记)
  - 是JS的一个严格子集
  - 是一种轻量级的数据交换格式，用来存储和表示数据，类似于xml/yaml
- JSON.parse()
- JSON.stringify(value, ?replacer, ?space)
  - replacer null,数组,函数 决定生成的JSON包含哪些属性
  - space null,数值,字符串 决定生成的JSON缩进空格数,缩进符号
  ```js
  JSON.stringify({
    undefined1: undefined,
    null1: null, // "null1":null
    boolean1: true, // "boolean1":true
    number1: 1.22, // "number1":1.22
    string1: 'abc', // "string1":"abc"
    [Symbol(23)]: 1,
    symbol1: Symbol(1123),
    bigint1: 123n, // Uncaught TypeError: Do not know how to serialize a BigInt
  });
  ```
- 有时候,对象需要自定义 JSON.stringify() 结果
  - 可以在要序列化的对象中添加 toJSON() 方法
  - 箭头函数不能用来定义 toJSON() 方法,主要原因是箭头函数的 this 指向
  ```js
  let book = {
    title: '中国文旭',
    author: ['郭静','黄荣'],
    toJSON: function() {
      return [this.title];
    },
  };
  JSON.stringify(book); // ["中国文旭"]
  ```

### 迭代器 Iterator
- 实现了正式的 *Iterable 接口* 的结构称为 "*可迭代对象*"(iterable),可以通过 *迭代器 Iterator* 消费
- 可迭代对象,暴露一个属性 Symbol.iterator => 迭代器工厂函数,调用工厂函数必须返回一个 迭代器A
- 很多内置类型都实现了 Iterable 接口：字符串、数组、映射、集合、arguments对象、NodeList DOM集合类型
  - 实际写代码过程中，不需要显试调用这个工厂函数来生成迭代器
    - 可接收可迭代对象的原生语言结构包括：
    - 1.for-of 循环
    - 2.数组解构 `[a, b] = new Set(['h', 'e']);`
    - 3.扩展操作符 `[...arr] = 'hello';`
    - 4.Arary.from()
    - 5.创建映射、集合 `Map([]) Set([]) WeakMap([]) WeakSet([])`
    - 6.Promise.all() / Promise.race() 接收由期约组成的可迭代对象
    - 7.yield*操作符,在生成器中使用
      ```js
      let gen = function* () { yield 1; yield* [2, 3, 4]; };
      let iter = gen();
      [...iter] // [1, 2, 3, 4, 5]
      ```
  - 迭代器A 是一种一次性使用的对象
    - next() 方法返回迭代器对象 IteratorResult { done: false, value: 23 }
    - 不同的迭代器的实例之间没有联系
      ```js
      const arr = ['a', 'b'];
      const iter1 = arr[Symbol.iterator]();
      const iter2 = arr[Symbol.iterator]();
      iter1.next(); // {value: "a", done: false}
      iter2.next(); // {value: "a", done: false}
      iter1.next(); // {value: "b", done: false}
      ```
    - 迭代器并不与可迭代对象某个时刻的快照绑定,仅仅使用游标来记录遍历可迭代对象的历程
      - 如果可迭代对象在迭代期间被修改了,那么迭代器也会反应相应的变化
- 自定义迭代器
  - 对象形式
    ```js
    // 可迭代对象
    const obj = {
      [Symbol.iterator]: function () {
        // 迭代器A
        return {
          i: 0,
          next: function() {
            this.i++;
            if (this.i > 2) {
              return {done: true, value: undefined}
            }
            return {done: false, value: this.i};
          }
        };
      }
    };
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // [1, 2]

    // Symbol.iterator 也可迭代
    const obj = {
      i: 0,
      [Symbol.iterator]: function () {
        // 迭代器A
        return this;
      },
      next: function() {
        this.i++;
        if (this.i > 2) {
          return {done: true, value: undefined}
        }
        return {done: false, value: this.i};
      },
    };
    const iter = obj[Symbol.iterator]();
    console.log([...obj]);
    console.log([...iter]);
    ```
  - 生成器形式
    ```js
    // 可迭代对象
    const obj = {
      [Symbol.iterator]: function * () {
        yield 1;
        yield 2;
      }
    };
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // [1, 2]
    ```
  - 类形式,实例只能被迭代一次
    ```js
    class Obj {
      i = 0;
      [Symbol.iterator]() {
        return this;
      }
      next() {
        this.i++;
        if (this.i > 2) {
          return {done: true, value: undefined}
        }
        return {done: false, value: this.i};
      }
    }
    const obj = new Obj();
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // []
    ```
  - 类形式
    ```js
    class Obj {
      [Symbol.iterator]() {
        let i = 0;
        return {
          next() {
            i++;
            if (i > 2) {
              return {done: true, value: undefined}
            }
            return {done: false, value: i};
          }
        };
      }
    }
    const obj = new Obj();
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // [1,2]
    ```
- 提前终止迭代器
  - 可选的 return() 方法用于指定迭代器提前关闭前执行的逻辑
  - 可能的情况包括:
    - 1.for-of 循环通过 break、contine、return、throw 提前退出
    - 2.解构操作并未消费所有值
  - return() 方法必须返回一个有效的 IteratorResult 对象, {done: true}
  - return 不会控制 迭代器是否关闭(是否 可以从上次离开的地方继续迭代)

### 生成器 Generator / GeneratorFunction
- 生成器的形式是一个函数,函数名称前面加个 星号(*) 表示它是一个生成器
- 只要是可以定义函数的地方,就可以定义生成器 *箭头函数不能用来定义生成器函数*
- 调用生成器函数会产生一个 生成器对象(具有next方法)
- 生成器对象实现了 Iteralbe 接口,*它默认的迭代器是自引用的*
  ```js
  function * G() {
    yield 1; yield 2; yield 3;
  }
  const g = G();
  g[Symbol.iterator]() === g // true !!! 它默认的迭代器是自引用的
  g.next(); // {value: 1, done: false}
  [...g]; // [2, 3]
  ```
- yield的应用
  - 获取某个范围的数组
    ```js
    function * range(a, b) {
      while (a < b + 1) {
        yield a++;
      }
    }
    for (let x of range(3, 5)) {
      console.log(x);
    }
    ```
  - 递归
    ```js
    function * f1(n) {
      if (n > 0) {
        yield* f1(n - 1);
        yield n - 1;
      }
    }
    console.log([...f1(10)]);
    ```
  - 斐波那契数列
    ```js
    function * f2(n) {
      let a = 1, b = 1;
      let i = 1;
      while (i <= n) {
        yield a;
        [a, b] = [b, a + b];
        i++;
      }
    }
    console.log([...f2(10)]);
    ```
- 提前终止生成器
  - return() 方法会强制生成器进入关闭状态,提供给return()方法的值,就是迭代器对象的值
    ```js
    function * f1() {
      yield 1; yield 2; yield 3;
    }
    const t1 = f1();
    t1.next(); // {value: 1, done: false}
    t1.return(4); // {value: 4, done: true}
    t1.next(); // {value: undefined, done: true}
    ```
  - throw() 方法会在暂停的时候将一个提供的错误注入到生成器对象,若错误未处理,生成器就会关闭
    ```js
    function * f1() {
      yield 1; yield 2; yield 3;
    }
    const t1 = f1();
    t1.next(); // {value: 1, done: false}
    try {
      t1.throw('error info');
    } catch (e) {
      console.log(e); // error info
    }
    t1.next(); // {value: undefined, done: true}
    ```
- next 方法的参数
  - yield 表达式本身没有返回值,或者说总是返回 undefined
  - next 方法可以带一个参数,该参数会被当作*上一个yield表达式的返回值*
    ```js
    function* f() {
      for (let i = 0; true; i++) {
        let reset = yield i;
        if (reset) i = -1;
      }
    }
    const g = f();
    g.next(); // {value: 0, done: false}
    g.next(); // {value: 1, done: false}
    g.next(true); // {value: 0, done: false}
    ```

### Promise
```js
new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve([1, 2, 3])
  }, 1000)
}).then(res => {
  console.log(res)
}).catch(res => {
  console.log(res)
}).finally(() => {
  console.log('finally')
})
```
- 异步编程的一种解决方案,比传统的'回调函数和事件'更合理更强大
- Promise对象代表一个异步操作,有3种状态: pending(待定)、fulfilled(兑现)和rejected(拒绝)
- Primise对象有2个特点：
  - 1.对象的状态不受外界影响
    - 只有异步操作结果可以决定当前是哪种状态
    - “承诺”,表示其他手段无法改变
  - 2.一旦状态改变,就不会再变
    - 状态改变只有2种可能:从pending->fulfilled,从pedding->rejected
    - 状态改变了,在对Promise添加回调函数,会立即得到结果
- Promise新建后会立即执行
  ```js
  const p1 = new Promise((resolve) => {
    // 里面的内容会立即执行
    console.log('123');
    setTimeout(() => resolve('abc'), 1000);
  });
  p1.then(value => console.log(value)); // abc
  ```
- Promise相互依赖
  - p2的回调函数会等待p1的状态改变,如果p1的状态是resolved或rejected,那么p2的回调函数会立刻执行
  - 调用resolve或reject后,Promise的使命就完成了,后续操作应放到then方法里面,最好在resolve前加return
  ```js
  const p1 = new Promise((resolve, reject) => setTimeout(() => reject('error'), 2000));
  const p2 = new Promise((resolve, reject) => setTimeout(() => resolve(p1), 1000));
  p2.then(
    (value) => console.log('resolve:' + value),
    (errro) => console.log('11111'), // 11111
  ).catch((error) => console.log('reject:' + error));
  ```
- `Promise.prototype.then()`
  - then方法返回一个新的Promise实例(注意:不是原来那个Promise实例)
  - 因此可以采用链式写法,then后面调用另一个then方法
  ```js
  // Promise 实例
  const f1 = async () => {
    const res = await new Promise((resolve) => {
      setTimeout(() => { resolve('p1'); }, 1000);
    });
    return [res, 'p2'];
  };
  f1().then(res => {
    console.log(res);
  }).catch(err => {
    console.log(err)
  });
  ```
- `Promise.prototype.catch()`
  - *是 .then(null, rejection) 或 .then(undefined, rejection) 的别名,用于指定发送错误时的回调函数*
  - 跟传统的 try/catch 代码块不同的是,如果没有catch()方法,Promise抛出的错误不会传递到外层,即不会有任何反应
  - Promise内部的错误(如变量未定义),不会影响到Promise外部的代码,通俗的说法是Promise会吃掉错误
  - reject() 方法的作用,等同于抛出错误
  ```js
  new Promise((resolve, reject) => {
    throw new Error('test');
  });
  // 等价于
  new Promise((resolve, reject) => {
    reject(new Error('test'));
  });
  ```
- `Promise.prototype.finally()`
  - finally() 方法是不管 Promise 对象最后状态如何,都会执行的操作
- `Promise.all()`
  - 实例都变成fulfilled 或 其中一个变成rejected
  - 无法确定所有实例都结束
  ```js
  const p1 = new Promise((resolve, reject) => {
    setTimeout(() => { resolve('p1'); }, 1000);
  });
  const p2 = new Promise((resolve, reject) => {
    setTimeout(() => { resolve('p2'); }, 1000);
  });
  const f1 = async () => {
    const res = await Promise.all([p1, p2]);
    res.push('p3');
    return res;
  };
  f1().then(res => {
    console.log(res);
  }).catch(err => {
    console.log(err)
  });
  ```
- `Promise.race()`
  - 有个实例率先改变状态,p的状态就跟着改变
  ```js
  // 5秒内未返回结果,就变为rejected
  (Promise.race([
    fetch('/a.js'),
    new Promise((resolve, reject) => setTimeout(() => reject('time out'), 5000)),
  ])).then().catch();
  ```
- `Promise.allSettled()`
  - 只有等待所有实例返回结果,不管是fulfilled还是rejected,包装实例才会结束
  ```js
  // 一旦结束,状态总是fulfilled
  Promise.allSettled([
    Promise.resolve(1),
    Promise.reject(-1),
  ]).then(res => {
    console.log(res);
  });
  // 0: {status: "fulfilled", value: 1}
  // 1: {status: "rejected", reason: -1}
  ```
- `Promise.any()`
  - 只要实例有一个变成fulfilled状态,包装实例就会变成fulfilled状态
- `Promise.resolve()`
  ```js
  // 两者等价
  let p1 = new Promise((resolve) => resolve(123));
  let p2 = Promise.resolve(123);

  Promise.resolve([1, 2, 3]).then(res => {
    console.log(res)
  }).catch(res => {
    console.log(res)
  }).finally(() => {
    console.log('finally')
  })
  ```
  - 将现有对象转换为Promise对象
  - *立即resovle的Promise对象,在本轮事件循环结束时执行,而不是在下一轮事件循环开始时*
    ```js
    setTimeout(() => console.log('3'), 0); // 下一轮事件循环开始时执行
    Promise.resolve().then(() => console.log(2)); // 本轮事件循环结束时执行
    console.log(1);
    // 1 2 3
    ```
  - 参数分为四种情况
    - 1.参数是一个Promise实例: Promise.resolve 将不做任何修改地返回这个实例
    - 2.参数是一个thenable对象: Promise.resolve 会将这个对象转为 Promise 对象,然后立即执行  thenable 对象的函数
      ```js
      let obj1 = { then: (resolve, reject) => resolve(42) };
      Promise.resolve(obj1).then(v => console.log(v)); // 42
      ```
    - 3.参数不具备then方法的对象,后根本不是对象: 则返回resolved
      ```js
      const p1 = Promise.resolve('Hello);
      p1.then(v => v); // Hello
      ```
    - 4.不带有任何参数:返回resolved
- `Promise.reject()`
  - 第一个 try/catch 抛出并捕获了异常，第二个 try/catch 抛出错误却没捕获到
  - 同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误
  ```js
  try {
    throw new Error('err1');
  } catch(e) {
    console.log(e);
  }
  // Uncaught (in promise) Error: err2
  try {
    Promise.reject(new Error('err2'));
  } catch(e) {
    console.log(e);
  }

  ```
- 例子：循环 同步 Promise
  ```js
  (async () => {
    for (let i = 1; i <= 10; i++) {
      await new Promise((resolve) => {
        setTimeout(() => {
          console.log(i);
          resolve();
        }, 1000);
      });
    }
  })();
  ```
  ```js
  // 无效,非同步,forEach里的函数只是参数
  (() => {
    [1, 2, 3, 4].forEach(async v => {
      await new Promise((resolve) => {
        setTimeout(() => {
          console.log(v);
          resolve();
        }, 1000);
      });
    });
  })();
  ```

### AsyncFunction(Async 函数)
- async 函数是 Generator 函数的语法糖
- async 函数返回的是 Promise 对象,可以作为 await 命令的参数
  - 1.内部 return 语句的返回值,会成为 then 方法回调函数的参数
    ```js
    async function f() { return 'hello'; }
    f().then(v => console.log(v)); // hello
    ```
  - 2.内部抛出错误,会知道变为 reject 状态
    ```js
    async function f() { throw new Error('出错了'); }
    f().then(null, e => console.log(e)); // 出错了
    ```
- async 函数返回的 Promise 对象,必须等到内部所以 await 命令后面的 Promise 对象执行完, 才会发生状态变化
  - 除非遇到 return 或 抛出错误
    ```js
    async function getA() {
      let s1 = await new Promise((resolve) => setTimeout(() => resolve('hello'), 5000));
      console.log('11');
      let s2 = await new Promise((resolve) => setTimeout(() => resolve('hello'), 5000));
      console.log('22');
      return `${s1} ${s2}`;
    }
    getA().then(v => console.log(v));
    ```
- await命令
  - 正常情况下, await 后面是一个 Promise 对象;如果不是 Promise 对象,则直接返回对应的值
    ```js
    async function f() {
      return await 123; // 等同于 return 123
    }
    ```
  - 另一种情况,await后面是一个 thenable 对象(即定义了then方法的对象),await会将其等同于 Promise 对象
    ```js
    class Sleep {
      then(resolve, reject) {
        setTimeout(() => resolve('131313'), 3000);
      }
    }
    await new Sleep();
    ```
- 变化历程
  - 0.JavaScript需要异步编程
    - 由于 JavaScript 是单线程执行模型,因此必须支持异步编程才能提高运行效率
    - 异步编程的语法目标是让异步过程写起来像同步过程
  - 1.回调函数
    - 就是把占用非CPU的任务的第二段单独写在一个函数中,等非CPU的任务完成后,直接调用这个函数(demo1)
    - 问题：容易形成回调地狱,代码可读性差(demo2)
  - 2.Promise
    - 利用编程技巧将回调函数改成链式调用,避免回调地狱
    - 问题：代码冗余,原来的语义变得不是很清楚(demo3)
  - 3.通过 generator函数+thunk函数 让回调函数实现同步过程(demo4)
    - generator 函数
      - 是协程在es6的实现,协程简单来说就是多个线程相互协作,完成异步任务
      - 整个 generator 函数就是一个封装的异步函数,异步操作需要暂停的地方,都用yield语句注明
    - thunk函数
      - 译为转换程序,简单来说就是把带有回调函数的多参数函数转换成只接收回调函数的单参数版本
      - thunk函数的真正作用是统一多参数函数的调用方式,在 next 调用时把控制权还给 generator
      - 使 generator 函数可以使用递归方式自启动流程
  - 4.通过 genertaor函数 让 Promise函数 实现同步过程(demo5)
  - 5.co 函数库
    - 每次执行 generator 函数时自己写启动器比较麻烦
    - co函数库是一个 generator 函数的自启动执行器
    - 使用条件是 generator 函数的yield命令后面只能是 thunk 函数或 Promise 对象
    - co函数执行完返回一个 Promise 对象
    - co函数库其实是将上面两种情况做了综合
  - 6.async/await
    - 为解决 Promise 的问题, async/await 在ES7中被提出来,是目前为止最好的解决方案
    - 是 co 库的官方实现,也可以看作自带启动器的 generator 函数的语法糖(demo6/demo7)
    - 不同的是 async/await 只支持 Promise 和原始类型的值,不支持 thunk 函数
  - 7.不论哪种方式,都没有改变 JavaScript单线程,使用回调处理异步任务的本质

  ```js
  // demo1.回调函数
  const f1 = (param, callback) => {
    // 执行非CPU任务(在此2s内NodeJs可以处理别的请求)
    setTimeout(() => callback(null, param), 2000);
  };

  // demo2.回调地狱
  // 连续执行3次
  f1('123', (err, res) => {
    console.log(res);
    f1('456', (err, res) => {
      console.log(res);
      f1('789', (err, res) => {
        console.log(res);
      });
    });
  });

  // demo3.Promise
  const f2 = (param) => new Promise((resove, reject) => {
    f1(param, (err, res) => err ? reject(err) : resove(res));
  });
  // 连续执行3次
  f2('123')
    .then(res => {
      console.log(res);
      return f2('456');
    })
    .then(res => {
      console.log(res);
      return f2('789')
    })
    .then(res => {
      console.log(res);
    });

  // demo4.使用chunk异步改同步
  function f1(ms, callback) {
    setTimeout(() => {
      console.log(ms);
      callback();
    }, ms);
  }
  function chunk(fn, ...params) {
    return function(callback) {
      return fn(...params, callback)
    }
  }
  const list = [
    chunk(f1, 1000),
    chunk(f1, 1000),
    chunk(f1, 1000),
  ];
  function doTask(list) {
    if (list.length < 1) return;
    const v = list.pop();
    v(() => {
      doTask(list);
    });
  }
  doTask(list);


  // demo4.通过generator+chunk函数 让回调函数 实现 async+await
  (() => {
    // thunk函数
    const chunk1 = function (...params) {
      return function (callback) {
        return f1(...params, callback);
      }
    };
    function* gen1() {
      let res = yield chunk1('123');
      console.log(res);

      res = yield chunk1('456');
      console.log(res);

      res = yield chunk1('789');
      console.log(res);
    }
    const run = generator => {
      const g1 = generator();
      const next = (err, res) => {
        // 修改了上次yield的返回值
        const result = g1.next(res);
        if (result.done) return result.value;
        result.value(next);
      };
      next();
    };
    run(gen1);
  })();

  // demo5.通过generator 让 Promise 实现 async+await
  (() => {
    function* gen1() {
      let res = yield f2('123');
      console.log(res);

      res = yield f2('456');
      console.log(res);

      res = yield f2('789');
      console.log(res);
    }
    const run = generator => {
      return new Promise((resolve, reject) => {
        const g1 = generator();
        const next = (err, res) => {
          // 修改了上次yield的返回值
          const v = g1.next(res);
          if (v.done) return resolve(v.value);
          v.value.then(res => {
            return next(null, res);
          }, err => {
            return reject(err);
          });
        };
        next();
      });
    };
    run(gen1);
  })();

  // demo6.co库 + Promise 实现 async/await
  co(function* () {
    let res = yield f2('123');
    console.log(res);

    res = yield f2('456);
    console.log(res);

    res = yield f2('789);
    console.log(res);
  });

  // demo7.async/await
  (async () => {
    let res = await f2('123);
    console.log(res);

    res = await f2('456);
    console.log(res);

    res = await f2('789);
    console.log(res);
  })();
  ```



### 代理(Proxy)与反射(Reflect)
```js
// 目标对象
const obj = {num: 123, arr: ['a', 'b']};
// Proxy(target:目标对象, handler:捕获器)
const proxy1 = new Proxy(obj, {
  get: function(target, propKey, receiver) {
    // 反射API
    return Reflect.get(...arguments);
  },
  set: function(target, propKey, value, receiver) {
    // 反射API
    return Reflect.set(...arguments);
  },
});
```
- ES6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力
- 开发者使用它可以创建出各种编码模式，如
  - 跟踪属性访问、隐藏属性、阻止修改或删除属性
  - 函数参数验证、构造函数参数验证
  - 数据绑定、可观察对象
- 处理程序对象中所有可以捕获的方法都有对象的反射(Reflect)API方法
- 捕获器不变式
  - 使用捕获器几乎可以改变所有基本方法的行为，但也有限制
  - 捕获处理程序的行为必须遵循"捕获器不变式"(trap invariant)
  - 例如：目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError
  ```js
  const obj = {};
  Reflect.defineProperty(obj, 'num', {
    configurable: false,
    value: 123,
  });
  const proxy1 = new Proxy(obj, {
    get: function(target, propKey, receiver) {
      if (propKey == 'num') return 456;
      return Reflect.get(...arguments);
    },
  });
  proxy1.num;
  // Uncaught TypeError: 'get' on proxy:
  // property 'num' is a read-only and non-configurable data property
  // on the proxy target but the proxy did not return
  // its actual value (expected '123' but got '456')
  ```
- 可撤销代理
  - Proxy 的 revocable() 方法支持撤销代理对象与目标对象的关联
  - 撤销代理操作是不可逆的
  ```j
  const obj = {};
  const { proxy, revoke } = Proxy.revocable(obj, {
    get() { return '123'; }
  });
  proxy.a; // 123
  revoke();
  proxy.a; // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revokeds
  ```
- 某些情况下应该优先使用 反射 API
  - 反射 API 并不限于捕获处理程序
  - 大多数反射 API 方法在 Object 类型中有对象的方法
  - 通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制和操作
  - 很多反射方法返回 "状态标记" 的布尔值，表示意图执行的操作是否成功
    - 而 Object 方法会抛出错误(取决于方法)
  - 用一等函数替代操作符
    - Reflect.get() 可替代对象属性访问操作符
    - Reflect.set() 可替代=赋值操作符
    - Reflect.has() 可替代 in 操作 或 width()
    - Reflect.deleteProperty() 可替代 delete 操作符
    - Reflect.construct() 可替代 new 操作符
  - 安全的 apply 函数
    ```js
    const f1 = (...arr) => console.log(arr);
    // 但f1可能也定义了apply属性(虽然可能性极小)
    f1.call({}, 1, 2, 3);
    f1.apply({}, [1, 2, 3]);
    f1.bind({}, 1, 2, 3)();
    // 为绕过这个问题,可以使用定义在 Function 原型上的 apply 方法
    Function.prototype.call.call(f1, {}, 1, 2, 3);
    Function.prototype.apply.call(f1, {}, [1, 2, 3]);
    Function.prototype.bind.call(f1, {}, 1, 2, 3);
    // 使用 Reflct.apply 可简化
    Reflect.apply(f1, {}, [1, 2, 3]);
    ```
- 代理的问题与不足
  - 代理中的 this
    - 方法中的 this 通常指向调用这个方法的对象
    - 代理执行目标有 this 操作的方法, this会指向 代理对象 而非 目标对象
  - 代理与内部槽位
    - 有些 ECMAScript 内置类型可能会依赖代理无法控制的机制
    - 导致在代理上调用某些方法会出错
    ```js
    const proxy = new Proxy(new Date(), {});
    proxy.getDate(); // Uncaught TypeError: this is not a Date object.
    ```
- 代理可以捕获13种不同的基本操作
  - 这些操作有各自的反射API方法、参数、关联 ECMAScript操作、不变式
  - 1.get(target:目标对象, property:属性, receiver:代理对象)
    - 返回值：无限制
    - 拦截的操作：
      - `proxy.s1`
      - `proxy['s1']`
      - `(Object.create(proxy)).s1`
      - `Reflect.get(proxy, 's1')`
  - 2.set(target:目标对象, property:属性, value:属性值, receiver:代理对象)
    - 返回值：true表示成功; false表示失败
    - 拦截的操作：
      - `proxy.s1 = 1;`
      - `proxy['s1'] = 1;`
      - `(Object.create(proxy)).s1 = 1;`
      - `Reflect.set(proxy, 's1', 1);`
  - 3.has(target:目标对象, property:属性)
    - 返回值：true表示存在; false表示不存在
    - 拦截的操作
      - `'s1' in proxy`
      - `'s1' in Object.create(proxy)`
      - `with(proxy) { s1; }` // has('s1')、get(Symbol(Symbol.unscopables))、get('s1')
      - `Reflect.has(proxy, 's1')`
  - 4.defineProperty(target:目标对象, property:属性, attributes:配置项)
    - 返回值：true表示成功; false表示失败
    - 拦截的操作
      - `Object.defineProperty(proxy, 's1', { value: 123 })`
      - `Reflect.defineProperty(proxy, 's1', { value: 123 })`
  - 5.getOwnPropertyDescriptor(target:目标对象, property:属性)
    - 返回值：存在返回对象；不存在返回 undefined
    - 拦截操作
      - `Object.getOwnPropertyDescriptor(proxy, 's1')`
      - `Reflect.getOwnPropertyDescriptor(proxy, 's1')`
  - 6.deleteProperty(target:目标对象, property:属性)
    - 返回值：true表示删除成功, false表示删除失败
    - 拦截操作
      - `delete proxy.s1`
      - `delete proxy['s1']`
      - `Reflect.deleteProperty(proxy, 's1')`
  - 7.ownKeys(target:目标对象)
    - 返回包含 字符串或符号 的可枚举对象
    - 拦截操作
      - `Object.getOwnPropertyNames(proxy)`
      - `Object.getOwnPropertySymbols(proxy)`
      - `Object.keys(proxy)`
      - `Reflect.ownKeys(proxy)`
  - 8.getPrototypeOf(target:目标对象)
    - 返回对象或null
    - 拦截操作
      - `Object.getPrototypeOf(proxy)`
      - `Reflect.getPrototypeOf(proxy)`
      - `proxy.__proto__`
      - `Object.prototype.isPrototypeOf(proxy)`
      - `proxy instanceof Object`
  - 9.setPrototypeOf(target:目标对象, handle:替代原型)
    - 返回 true 表示成功, false 表示失败
    - 拦截操作
      - `Object.setPrototypeOf(proxy, proto)`
      - `Reflect.setPrototypeOf(proxy, proto)`
  - 10.isExtensible(target:目标对象)
    - 返回 true 表示可扩展
    - 拦截操作
      - `Object.isExtensible(proxy)`
      - `Reflect.isExtensible(proxy)`
  - 12.preventExtensions(target:目标对象)
    - 返回 true 表示已经不可扩展
    - 拦截操作
      - `Object.preventExtensions(proxy)`
      - `Reflect.preventExtensions(proxy)`
  - 13.apply(target:目标对象, thisArg:调用函数时的this参数, argumentsList:调用函数时的参数列表)
    - 返回值无限制
    - 拦截操作
      - `proxy.apply({}, ['abc'])`
      - `proxy.call({}, 'abc')`
      - `proxy.bind({}, 'abc')()`
      - `Reflect.apply(proxy, {}, ['abc'])`
  - 14.construct(target:目标对象, argArray:传给构造函数的参数, newTarget:最初被调用的构造函数)
    - 返回值必须返回一个对象
    - 拦截操作
      - `new proxy('abc')`
      - `Reflect.construct(proxy, ['abc'])`


### 对象:国际化
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.ListFormat
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Locale

### 对象:WebAssembly
WebAssembly
WebAssembly.Module
WebAssembly.Instance
WebAssembly.Memory
WebAssembly.Table
WebAssembly.CompileError
WebAssembly.LinkError (en-US)
WebAssembly.RuntimeError