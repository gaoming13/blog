### Object(function)
- 构造函数方法
  - `Object.assign(target:目标对象, ...sources:源对象)` 所有源对象可枚举属性复制到目标对象,并返回目标对象
    - 目标对象(target)会被修改
    - 因为拷贝的是属性的值.
      - 若源对象的属性值是一个对象的引用，那么它指向引用，为浅拷贝.
      - 若源对象的属性值是一个简单类型(如string,number), 为深拷贝
  - `Object.create(proto:原型对象[, propertiesObject:添加的属性])` 创建一个对象,原型 __proto__ 指向原型对象,并返回该对象
  - `Object.keys(obj)` 所有属性(自身,仅可枚举的),返回数组
  - `Object.getOwnPropertyNames(obj)` 所有属性(自身),返回数组
  - `Object.getPrototypeOf(obj)` 获取对象的`[[Prototype]]`, ES6开始使用该函数来访问, 等同于 非标准但许多浏览器实现的属性 `__proto__`
  - `Object.setPrototypeOf(obj)`
- 原型对象方法(Object.prototype)
  - `hasOwnProperty(prop)` 是否存在某个属性(自身),并返回布尔值

### 对象实例的属性
- 对象的属性名可以是任意有效的 JS 字符串，或者可以转换为字符串的任何类型，包括空串
- 未赋值的对象属性的值是 `undefined` (而不是null)
- 如何遍历属性
  - 1.`Object.keys(obj)` 遍历属性(自身,仅可枚举的)
  - 2.`Object.getOwnPropertyNames(obj)` 遍历属性(自身)
  - 3.`for k in obj` 遍历属性(自身+原型链,仅枚举的)
  ```js
  const arr = ['a', 'b'];
  arr.p1 = '123';
  Object.prototype.p2 = '456';
  // `Object.keys(obj)` (自身,仅可枚举的)
  console.log(Object.keys(arr)); // ["0", "1", "p1"]
  // `Object.getOwnPropertyNames(obj)` (自身)
  console.log(Object.getOwnPropertyNames(arr)); // ["0", "1", "length", "p1"]
  // `for k in obj` (自身+原型链,仅枚举的)
  for (const k in arr) { console.log(k); } // 0 1 p1 p2
  ```
- 判断属性是否存在
  - `undefined` 不能够判断对象属性是否存在
  - 1.`hasOwnProperty` 是否存在(自身)
  - 2.`'a' in obj` 是否存在(自身+原型链,仅枚举的)
- 定义 getters 与 setters
  ```js
  const obj = {
    p1: 1,
    get p2() { return this.p1 + 1; },
    set p3(x) { this.p1 = x * 2 },
  };
  Object.defineProperty(obj, 'p4', {
    get: function() { return this.p1; },
    set: function(x) { this.p1 = x + 1 },
  });
  Object.defineProperties(obj, {
    'p5': { get: function() { return 3; } },
    'p6': { get: function() { return 4; } },
  });
  ```
- 如何删除属性
  - `delete obj.p1`


### 对象实例创建方式
- 1.通过构造函数
  ```js
  function User(name, age) { this.name = name; this.age = age; this.setAge = age => { this.age = age; }; }
  User.getAgeLabel = (age) => age > 18 ? '成年' : '儿童';
  function Car(name, user) { this.name = name; this.user = user; }

  const zhangsan = new User('张三', 20);
  zhangsan.setAge(5);
  const jeep = new Car('吉普', zhangsan);
  console.log(User.getAgeLabel(jeep.user.age));
  ```
- 2.使用对象初始化器(通过字面值创建对象)
- 3.使用 Object.create

### 对象继承
- 每个实例对象(Object)都有一个私有属性(__proto__) 指向它的构造函数的原型对象(prototype)
- 该原型对象也有一个自己的原型对象(__proto__)，层层向上直到一个对象的原型对象为null
- 根据定义，null 没有原型，并作为原型链的最后一个环节

#### 1.ES6 class 实现(引用关系,修改父类影响子类)
```js
class C1 {
  constructor(num) { this.num = num; }
  add(x) { this.num += x; }
}
class C2 extends C1 {
  constructor(x) { super(x); }
}
const c2 = new C2(10);
```

```
c1(object)
> num: 1
> __proto__ ················
                           ·
C2(function)               ·
> name: 'C2'               ·
> prototype(object) <·······
  > constructor(self)
  > __proto__  ········
> __proto__  ····     ·
                ·     ·
C1(function)    ·     ·
> name: 'C1' <···     ·
> prototype(object) <··
  > constructor(self)
  > __proto__           => Object.prototype
  > add: f
> __proto__             => Function.prototype
```

#### 2.Object.create 实现(拷贝关系,修改父类不影响子类)

```js
const C1 = function(num) {
  this.num = num;
  this.add = function(x) { this.num += x; }
}
const C2 = function(num) {
  C1.call(this, num);
}
C2.prototype = Object.create(C1.prototype);
C2.prototype.constructor = C2;

const c2 = new C2(10);
```

```
c1(object)
> num: 1
> add: f
> __proto__ ················
                           ·
C2(function)               ·
> name: 'C2'               ·
> prototype(object) <·······
  > constructor(self)
  > __proto__  ········
> __proto__           · => Function.prototype
                      ·
C1(function)          ·
> name: 'C1'          ·
> prototype(object) <··
  > constructor(self)
  > __proto__           => Object.prototype
  > add: f
> __proto__             => Function.prototype
```

### 创建层级结构

```java
public class Car {
  public String name = '汽车';
}
public class Jeep {
  public String name = '吉普';
  public String color = 'blue';
}
```

```js
function Car() {
  this.name = '汽车';
}
function Jeep() {
  Car.call(this);
  this.name = '吉普';
  this.color = 'blue';
}
Jeep.prototype = Object.create(Car.prototype);

// 1.执行 new 操作符时，会先创建一个普通对象
// 2.将这个普通对象的 prototype 指向 `Jeep.prototype`
// 3.将这个普通对象设置为执行 Jeep 构造函数时的 this 的值
// 4.构造函数执行完后，所有属性都被设置完毕，JavaScript 返回之前创建的对象
const jeep1 = new Jeep();
```

### 应用
- 合并2个对象
  - Object.assign({}, a, b) // 第一层属性为深拷贝, 第二层属性为浅拷贝
- 浅拷贝
  - $.extend({}, obj) // 同 Object.assign
- 深拷贝
  - JSON.parse(JSON.stringify(obj)) // 对象中包含 function 或 RegExp 的不能用这个方法
  - $.extend(true, {}, obj) // 第一个参数为 true 表示深拷贝, 无法拷贝 defineProperty
  - _.cloneDeep(obj1) // lodash 实现深拷贝, 无法拷贝 defineProperty
  ```js
  function _deepClone(source) {
    if (typeof source !== 'object') {
      return source;
    }
    let target = Array.isArray(source) ? [] : {};
    for (const key in source) {
      console.log(key);
      if (source.hasOwnProperty(key)) {
        if (typeof source[key] === 'object') {
          target[key] = deepClone(source[key]);
        } else {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  ```