### Object(function)
- 构造函数方法
  - `Object.assign(target:目标对象, ...sources:源对象)` 所有源对象可枚举属性复制到目标对象,并返回目标对象
    - 非深拷贝,拷贝的属性值
    - 目标对象(target)会被修改
  - `Object.create(proto:原型对象[, propertiesObject:添加的属性])` 创建一个对象,原型 __proto__ 指向原型对象,并返回该对象
  - `Object.keys(obj)` 所有属性(自身,仅可枚举的),返回数组
  - `Object.getOwnPropertyNames(obj)` 所有属性(自身),返回数组
- 原型对象方法(Object.prototype)
  - `hasOwnProperty(prop)` 是否存在某个属性(自身),并返回布尔值

### 对象实例的属性
- 对象的属性名可以是任意有效的 JS 字符串，或者可以转换为字符串的任何类型，包括空串
- 未赋值的对象属性的值是 `undefined` (而不是null)
- 如何遍历属性
  - 1.`Object.keys(obj)` 遍历属性(自身,仅可枚举的)
  - 2.`Object.getOwnPropertyNames(obj)` 遍历属性(自身)
  - 3.`for k in obj` 遍历属性(自身+原型链,仅枚举的)
  ```js
  const arr = ['a', 'b'];
  arr.p1 = '123';
  Object.prototype.p2 = '456';
  // `Object.keys(obj)` (自身,仅可枚举的)
  console.log(Object.keys(arr)); // ["0", "1", "p1"]
  // `Object.getOwnPropertyNames(obj)` (自身)
  console.log(Object.getOwnPropertyNames(arr)); // ["0", "1", "length", "p1"]
  // `for k in obj` (自身+原型链,仅枚举的)
  for (const k in arr) { console.log(k); } // 0 1 p1 p2
  ```
- 判断属性是否存在
  - `undefined` 不能够判断对象属性是否存在
  - 1.`hasOwnProperty` 是否存在(自身)
  - 2.`'a' in obj` 是否存在(自身+原型链,仅枚举的)
- 定义 getters 与 setters
  ```js
  const obj = {
    p1: 1,
    get p2() { return this.p1 + 1; },
    set p3(x) { this.p1 = x * 2 },
  };
  Object.defineProperty(obj, 'p4', {
    get: function() { return this.p1; },
    set: function(x) { this.p1 = x + 1 },
  });
  Object.defineProperties(obj, {
    'p5': { get: function() { return 3; } },
    'p6': { get: function() { return 4; } },
  });
  ```
- 如何删除属性
  - `delete obj.p1`


### 对象实例创建方式
- 1.通过构造函数
  ```js
  function User(name, age) { this.name = name; this.age = age; this.setAge = age => { this.age = age; }; }
  User.getAgeLabel = (age) => age > 18 ? '成年' : '儿童';
  function Car(name, user) { this.name = name; this.user = user; }

  const zhangsan = new User('张三', 20);
  zhangsan.setAge(5);
  const jeep = new Car('吉普', zhangsan);
  console.log(User.getAgeLabel(jeep.user.age));
  ```
- 2.使用对象初始化器(通过字面值创建对象)
- 3.使用 Object.create

### 对象继承

#### 1.ES6 class 实现(引用关系,修改父类影响子类)
```js
class C1 {
  constructor(num) { this.num = num; }
  add(x) { this.num += x; }
}
class C2 extends C1 {
  constructor(x) { super(x); }
}
const c2 = new C2(10);
```

```
c1(object)
> num: 1
> __proto__ ················
                           ·
C2(function)               ·
> name: 'C2'               ·
> prototype(object) <·······
  > constructor(self)
  > __proto__  ········
> __proto__  ····     ·
                ·     ·
C1(function)    ·     ·
> name: 'C1' <···     ·
> prototype(object) <··
  > constructor(self)
  > __proto__           => Object.prototype
  > add: f
> __proto__             => Function.prototype
```

#### 2.Object.create 实现(拷贝关系,修改父类不影响子类)

```js
const C1 = function(num) {
  this.num = num;
  this.add = function(x) { this.num += x; }
}
const C2 = function(num) {
  C1.call(this, num);
}
C2.prototype = Object.create(C1.prototype);
C2.prototype.constructor = C2;

const c2 = new C2(10);
```

```
c1(object)
> num: 1
> add: f
> __proto__ ················
                           ·
C2(function)               ·
> name: 'C2'               ·
> prototype(object) <·······
  > constructor(self)
  > __proto__  ········
> __proto__           · => Function.prototype
                      ·
C1(function)          ·
> name: 'C1'          ·
> prototype(object) <··
  > constructor(self)
  > __proto__           => Object.prototype
  > add: f
> __proto__             => Function.prototype
```
