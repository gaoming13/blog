### 变量
- 变量声明
  - var 变量
    - `if(true){ var x = 10; } console.log(x);` OK
  - let 块作用域变量
    - `if(true){ let x = 10; } console.log(x);` ERROR
  - const 块作用域只读变量 (注：对象属性 与 数组内值 不受只读保护)
- 变量提升
  - `console.log(x === undefined); var x = 2; => true` OK
  - 变量先用，后 var 声明，不会引发异常，但用的时候变量还是为 undefined
- 变量类型(7种基本数据类型+对象)
  - `Boolea` 布尔值 true 和 false
  - `null` 一个表明 null 值的特殊关键字
  - `undefined` 一个表明变量未定义的特殊关键字
  - `Number` 整数或浮点数, 42 或 42.123 或 Infinity
  - `BigInt` 任意精度整数, 可安全的存储和操作大整数, 甚至可以超过数字的安全整数限制
  - `String` 字符串
  - `Symbol` 代表, ES6 新加的类型, 一种实例是唯一且不可改变的数据类型
  - `Object` 对象
- String 转换为 Number
  - parseInt(字符串, 进制) 只返回整数部分
  - parseFloat(字符串)

### 运算符
- 赋值运算符(Assignment operator) `x=y` `x+=y` ...
  - 解构 `let [v1, v2, v3]=[1, 2, 3]`
- 比较运算符(Comparison operator) `==` `===` `!=` `!==` `>`...
- 算术运算符(Arithmitic operator)
  - 求余(%) `12%5`
  - 自增(++),自减(--) `x++` `++x` `x--` `--x`
  - 一元正值符(+),一元负值符(-) `-'3'` `+'3'` 自动转换为Number,异常返回 NaN
  - 指数运算符(**) `2**3` 8 `10**-1` 0.1
- 位运算符(Bitwise operator) 将操作数视为32位元的二进制串(`(1024).toString(2)`)
  - 按位与(AND) `a&b` 对应位都为1,则返回1,否则返回0
  - 按位或(OR) `a|b` 对应位有1个为1,则返回1,否则返回0
  - 按位异或(XOR) `a^b` 对应位不相同则返回1,相同则返回0 `12^5=9`
  - 按位非(NOT) `~a` 按小数点对调所有位(~a = -a - 1)
    - 5 = 00000000 00000000 00000000 00000101
    - ~5 = 按位取反 = 1111111 1111111 1111111 11111010
    - 由于32位开头是1,所以这是个负数,将二进制转换成负数，需要先反码
    - 00000000 00000000 00000000 00000101
    - 之后，再+1
    - 00000000 00000000 00000000 00000110 = -6
  - 左移(shift) `a<<1` 所有位向左移动1位,右边补0
  - 算术右移 `a>>1` 所有位向右移动1位
- 逻辑运算符(Logical operator) `&&` `||` `!`
- 字符串运算符(String operator) `'my' + ' dog'`
- 逗号运算符(Comma operator) `for(var i=0,j=9; i<=j; i++){}`
- 关系运算符(Relational operator)
  - in 如果指定的属性存在于所指定的对象中,则返回true `prop1 in obj`
  - instanceof 判断对象是否是指定的类型 `obj1 instanceof ojd`
- 一元运算符(Unary operator)
  - delete 删除对象属性 `delete obj.prop1`
  - typeof
  - void 表明一个运算没有返回值 `javascript:void(0)`
- 条件(三元)运算符(Conditional operator) `条件 ? 值1:值2`

### 循环与迭代
- label 语句
```js
label1:
for (var i = 0; i < 100; i++) {
  for (var j = 0; j < 100; j++) {
    if (i === 5) continue label1; // 停止本次循环,跳转到label1下的循环继续
  }
}

label2:
for (var i = 0; i < 100; i++) {
  for (var j = 0; j < 100; j++) {
    if (i === 5) break label2; // 停止本次循环,跳出到label1下的循环
  }
}
```
- for:
- for...in: 以任意顺序遍历对象的除Symbol以外的可枚举属性名(数组对象会返回 数组下标 + 自定义属性名!!!)
  - 通常，在迭代过程中最好不要对对象属性进行添加、修改、删除的操作
  - 不应该用于迭代一个Array,不能保证索引顺序
  - 仅迭代自身的属性，只考虑对象本身的属性，而不是它的原型：`Object.getOwnPropertyNames(obj)` 或 `obj.hasOwnProperty('a')`
  - `var obj = {a:1, b:2}; function C() { this.c = '3'; }; C.prototype = obj; var obj1 = new C();`
  - `for (var i in obj1) { if (obj1.hasOwnProperty(i)) console.log(i); }` => `c`
  - `let obj = {a: 1, b: 2}; obj.__proto__.c = 3; for (let i in obj) { console.log(i); }` => `a b c`
- for...of: 在可迭代对象(Array、Map、Set、String、TypedArray、arguments)上创建一个迭代循环
  - `break / throw / continue / return` 可跳出循环
  - 迭代Array: `for (let v of [1, 2, 3]) { console.log(v) }`
  - 迭代String: `for (let v of 'abc') { console.log(v) }`
  - 迭代TypedArray: `for (let v of (new Uint8Array([0x00, 0xff]))) { console.log(v) }`
  - 迭代Map: `for (let [k, v] of (new Map([['a', 1]]))) { console.log({k, v}) }`
  - 迭代Set: `for (let v of (new Set([1, 2, 3]))) { console.log(v) }`
  - 迭代arguments `(function() { for (let v of arguments) { console.log(v) } })(1, 2, 3);`
  - 迭代DOM集合 `for (let v of document.querySelectorAll('p')) { console.log(v) }`
  - 迭代生成器 `function* f() { i = 0; while(true) { i += 1; yield(i); } }; for (let v of f()) { console.log(v) }`
  - for...in 与 for...of 对比
    - `Object.prototype.p1 = '123'; Array.prototype.p2 = '456';`
    - `let obj1 = [1, 2, 3]; obj1.a = '123';`
    - `for (let k in obj1) { console.log(k); }` => `0 1 2 a p2 p1`
    - `for (let k in obj1) { if (obj1.hasOwnProperty(k)) console.log(k); }` => `0 1 2 a`
    - `for (let v of obj1) { console.log(v); }` => `1 2 3`
    - `let obj2 = {a: '123'};`
    - `for (let k in obj2) { console.log(k); }` => `a p1`
    - `for (let k in obj2) { if (obj2.hasOwnProperty(k)) console.log(k); }` => `a`

### 函数
- 包含 函数声明 与 函数表达式
  - 函数声明 `function f1() {}`
  - 函数表达式 `const f1 = function f2() { console.log(f1 === f2); }` // 在函数体内 f1 与 f2 等价
  - 函数表单式(匿名) `const f1 = function() {}`
- 函数提升
  - 函数声明,有函数提升 `f1(); function f1(){}` OK
  - 函数表达式,没函数提升 `f1(); var f1 = function(){}` ERROR(f2 is not a function)
- 函数改变外部变量值
  - 基础数据类型作为参数传给函数，函数改变了这个参数，外部变量不变 `function f1(v){v=1;}; let a=0; f1(a);` a=0
  - 对象作为参数传给函数，函数改变了这个参数的属性，外部变量也会变 `function f1(v){v.push(1);}; let a=[]; f1(a);` a=[1]
- 函数参数
  - 函数的实际参数保存在一个类似数组的 arguments 对象中 `function f() { for (const v of arguments) { console.log(v); } }; f(1, 2, 3);`
  - 默认参数(es6) `function f(a = 0) {}`
  - 剩余参数(es6) `function f(a, ...b) {}`
- 闭包: 当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了
  - 内部函数只能在外部函数中访问
  - 内部函数形成了一个闭包：内部函数可以访问外部函数的参数和变量，但外部函数却不能使用它的参数和变量
  ```js
  // 闭包1
  function out(x, y) {
    function in(x) { return x * x; }
    return in(x) + in(y);
  }
  // 闭包2
  function pet(name) {
    let sex = '';
    return {
      getSex: () => sex,
      setSex: (sex) => { sex = sex },
      getName: () => name,
    };
  };
  const dog = pet('dog');
  dog.getName();
  dog.setSex('girl');
  dog.getSex();
  ```