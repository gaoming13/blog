### this指向:
- 在绝对多数情况下,函数的调用方式决定了`this`的值。`this`不能在执行期间被赋值，每次函数被调用时`this`的值也有可能不同。
- ES5引入了`bind`方法来设置函数的`this`值，而不用考虑函数如何被调用的
- ES2015引入了支持`this`词法解析的箭头函数(它在闭合的执行环境内设置`this`的值)
- 1.全局环境中: this指向全局对象 `console.log(this);` => `window`
- 2-1.函数简单调用,非严格模式: this指向全局对象 `(function() { console.log(this); })();` => `window`
- 2-2.函数简单调用,严格模式: this保持他进入执行环境时的值,如果this没有被执行环境(execution context)定义,那它将保持为`undefined`
  - `(function() { 'use strict'; console.log(this); })();` => `undefined`
  - 如果想把this的值从一个环境传到另一个,可用`call`或`apply`方法
    - `(function() { 'use strict'; console.log(this); }).call({ a: 123 })` => `{a: 123}`
  - 当一个函数在其主体内使用this关键字时,可以使用函数继承自`Function.prototype`的`call`或`apply`将this绑定到调用中的特定对象
    - `(function(c, d) { console.log(this.a + this.b + c + d); }).call({ a: '1', b: '2' }, '3', '4')` => `1234`
    - `(function(c, d) { console.log(this.a + this.b + c + d); }).apply({ a: '1', b: '2' }, ['3', '4'])` => `1234`
- 3.bind方法：ES2015引入的`Function.prototype.bind`,调用`f.bind(obj)`会创建一个与f具有相同函数体和作用域的函数,this永久被绑定到obj,无论函数如何被调用
  - `function f() { console.log(this); }; var f1 = f.bind({a: '123'}); var f2 = f1.bind({a: '456'}); var obj = { f1, f2 };`
  - `console.log(obj.f1()); console.log(obj.f2());` => `{a: '123'}  {a: '123'}`
- 4.对象的方法: 函数作为对象中的方法被调用时，this是调用该函数的对象; 这样的行为不受函数定义方式或位置的影响
  - `var obj = {a: '123', obj1: { b: '345', f: function() { return this } }}` => `{b: '345', f}`
  - `function f() { return this }; var obj = {a: '123', f}; obj.f()` => `{a: '123', f}`
- 5.原型链中的方法：同上, 如果方法存在于对象的原型链上，那么this是调用这个方法的对象
  - `var obj = {f: function() { return this; }}; var obj1 = Object.create(obj); obj1.a = '123'; obj1.f()` => `{a: '123'}`
- 6.getter与setter中：同上，this是设置或获取属性的对象
  - `var obj = {a: '123', b: {c: '456'}}; Object.defineProperty(obj.b, 'd', {get: function() { return this }}); obj.b.d` => `{c: '456'}`
- 7.构造函数：当一个函数用作构造函数时(使用new关键字), this是正在构造的新对象；虽然构造器默认返回this指的对象,但可手动返回其它对象
  - `function C() { this.a = '123'; console.log(this); return {b: '456'}; }; new C()` => `C {a: "123"} {b: "456"}`
- 8.dom事件处理函数：
  - `$0.addEventListener('click', function() { console.log(this); })` => `当前元素`
  - `$0.addEventListener('click', function() { (function() { console.log(this); })(); })` => `window`
- 9.内联事件处理函数
  - `onclick="console.log(this);"` => `当前元素`
  - `onclick="(function() { console.log(this); })()"` => `window`
- 10.箭头函数: this与封闭词法环境的this保持一致,即被设置为创建他时的环境; 如果通过`call/apply/bind`传递this,它将被忽略;
  - `(() => this)() === this` => `true`
  - `(() => this).call({a: 123}) === this` => `true`
  - `var obj = {f: function() { return () => this }}; (obj.f())() === obj` => `true`
  - `var obj = {f: function() { return () => this }}; var obj1 = {a: 123, f: obj.f}; (obj1.f())() === obj` => `false`
  - 箭头函数不能用作构造器,和 new 一起用会抛出错误 `var C = () => {}; new C();` // // TypeError: Foo is not a constructor
  - 箭头函数没有 prototype 属性 `var f = () => {}; f.prototype;` // undefined
  - 箭头函数也可以使用闭包
    - 标准闭包函数: `function f() { var i = 0; return function() { return ++i; } }; var a = f(); a(); a();`
    - 箭头函数的闭包：`var f = (i = 0) => () => ++i; var a = f(); a(); a();`