### Async 函数
- async 函数是 Generator 函数的语法糖
- async函数返回的是 Promise 对象,可以作为 await 命令的参数
  - 1.内部 return 语句的返回值,会成为 then 方法回调函数的参数
    ```js
    async function f() { return 'hello'; }
    f().then(v => console.log(v)); // hello
    ```
  - 2.内部抛出错误,会知道变为 reject 状态
    ```js
    async function f() { throw nwe Error('出错了'); }
    f().then(null, e => console.log(e)); // 出错了
    ```
- async函数返回的 Promise 对象,必须等到内部所以 await 命令后面的 Promise 对象执行完, 才会发生状态变化
  - 除非遇到 return 或 抛出错误
    ```js
    async function getA() {
      let s1 = await new Promise((resolve) => setTimeout(() => resolve('hello'), 5000));
      console.log('11');
      let s2 = await new Promise((resolve) => setTimeout(() => resolve('hello'), 5000));
      console.log('22');
      return `${s1} ${s2}`;
    }
    getA().then(v => console.log(v));
    ```
- await命令
  - 正常情况下, await 后面是一个 Promise 对象;如果不是 Promise 对象,则直接返回对应的值
    ```js
    async function f() {
      return await 123; // 等同于 return 123
    }
    ```
  - 另一种情况,await后面是一个 thenable 对象(即定义了then方法的对象),await会将其等同于 Promise 对象
    ```js
    class Sleep {
      then(resolve, reject) {
        setTimeout(() => resolve('131313'), 3000);
      }
    }
    await new Sleep();
    ```

### 变化历程
- 0.JavaScript需要异步编程
  - 由于 JavaScript 是单线程执行模型,因此必须支持异步编程才能提高运行效率
  - 异步编程的语法目标是让异步过程写起来像同步过程
- 1.回调函数
  - 就是把占用非CPU的任务的第二段单独写在一个函数中,等非CPU的任务完成后,直接调用这个函数(demo1)
  - 回调函数的最大问题是容易形成回调地狱,降低代码的可读性(demo2)
- 2.Promise
  - 为解决回调函数的不足,社区创造出 Promise
  - 实际是利用编程技巧将回调函数改成链式调用,避免回调地狱
  - 最大的问题的代码冗余,原来的语义变得不是很清楚(demo3)
- 3.通过 generator函数+thunk函数 让回调函数实现同步过程(demo4)
  - generator 函数
    - 是协程在es6的实现,协程简单来说就是多个线程相互协作,完成异步任务
    - 整个 generator 函数就是一个封装的异步函数,异步操作需要暂停的地方,都用yield语句注明
  - thunk函数
    - 译为转换程序,简单来说就是把带有回调函数的多参数函数转换成只接收回调函数的单参数版本
    - thunk函数的真正作用是统一多参数函数的调用方式,在 next 调用时把控制权还给 generator
    - 使 generator 函数可以使用递归方式自启动流程
- 4.通过 genertaor函数 让 Promise函数 实现同步过程(demo5)
- 5.co 函数库
  - 每次执行 generator 函数时自己写启动器比较麻烦
  - co函数库是一个 generator 函数的自启动执行器
  - 使用条件是 generator 函数的yield命令后面只能是 thunk 函数或 Promise 对象
  - co函数执行完返回一个 Promise 对象
  - co函数库其实是将上面两种情况做了综合
- 6.async/await
  - 为解决 Promise 的问题, async/await 在ES7中被提出来,是目前为止最好的解决方案
  - 是 co 库的官方实现,也可以看作自带启动器的 generator 函数的语法糖(demo6/demo7)
  - 不同的是 async/await 只支持 Promise 和原始类型的值,不支持 thunk 函数
- 7.不论哪种方式,都没有改变 JavaScript单线程,使用回调处理异步任务的本质

### 变化历程.DEMO

```js
// demo1.回调函数
const f1 = (param, callback) => {
  // 执行非CPU任务(在此2s内NodeJs可以处理别的请求)
  setTimeout(() => callback(null, param), 2000);
};

// demo2.回调地狱
// 连续执行3次
f1('123', (err, res) => {
  console.log(res);
  f1('456', (err, res) => {
    console.log(res);
    f1('789', (err, res) => {
      console.log(res);
    });
  });
});

// demo3.Promise
const f2 = (param) => new Promise((resove, reject) => {
  f1(param, (err, res) => err ? reject(err) : resove(res));
});
// 连续执行3次
f2('123')
  .then(res => {
    console.log(res);
    return f2('456');
  })
  .then(res => {
    console.log(res);
    return f2('789')
  })
  .then(res => {
    console.log(res);
  });

// demo4.通过generator+chunk函数 让回调函数 实现 async+await
(() => {
  // thunk函数
  const chunk1 = function (...params) {
    return function (callback) {
      return f1(...params, callback);
    }
  };
  function* gen1() {
    let res = yield chunk1('123');
    console.log(res);

    res = yield chunk1('456');
    console.log(res);

    res = yield chunk1('789');
    console.log(res);
  }
  const run = generator => {
    const g1 = generator();
    const next = (err, res) => {
      // 修改了上次yield的返回值
      const result = g1.next(res);
      if (result.done) return result.value;
      result.value(next);
    };
    next();
  };
  run(gen1);
})();

// demo5.通过generator 让 Promise 实现 async+await
(() => {
  function* gen1() {
    let res = yield f2('123');
    console.log(res);

    res = yield f2('456');
    console.log(res);

    res = yield f2('789');
    console.log(res);
  }
  const run = generator => {
    return new Promise((resolve, reject) => {
      const g1 = generator();
      const next = (err, res) => {
        // 修改了上次yield的返回值
        const result = g1.next(res);
        if (result.done) return resolve(result.value);
        result.value.then(res => {
          return next(null, res);
        }, err => {
          return reject(err);
        });
      };
      next();
    });
  };
  run(gen1);
})();

// demo6.co库 + Promise 实现 async/await
co(function* () {
  let res = yield f2('123');
  console.log(res);

  res = yield f2('456);
  console.log(res);

  res = yield f2('789);
  console.log(res);
});

// demo7.async/await
(async () => {
  let res = await f2('123);
  console.log(res);

  res = await f2('456);
  console.log(res);

  res = await f2('789);
  console.log(res);
})();
```