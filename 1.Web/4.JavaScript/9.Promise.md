### Promise
- 异步编程的一种解决方案,比传统的'回调函数和事件'更合理更强大
- Promise对象代表一个异步操作,有3种状态: pending(进行中)、fulfilled(已成功)和rejected(已失败)
- Primise对象有2个特点：
  - 1.对象的状态不受外界影响
    - 只有异步操作结果可以决定当前是哪种状态
    - “承诺”,表示其他手段无法改变
  - 2.一旦状态改变,就不会再变
    - 状态改变只有2种可能:从pending->fulfilled,从pedding->rejected
    - 状态改变了,在对Promise添加回调函数,会立即得到结果

#### Promise新建后会立即执行
```js
const p1 = new Promise((resolve) => {
  // 里面的内容会立即执行
  console.log('123');
  setTimeout(() => {
    resolve('abc');
  }, 1000);
});
p1.then(value => {
  console.log(value); // abc
});
```

#### Promise相互依赖
- p2的回调函数会等待p1的状态改变,如果p1的状态是resolved或rejected,那么p2的回调函数会立刻执行
```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => reject('error'), 3000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve(p1), 1000);
});
p2
  .then(value => console.log('resolve:' + value), errro => console.log('11111')) // 11111
  .catch(error => console.log('reject:' + error));
```

#### Promise.prototype.then()
- then方法返回一个新的Promise实例(注意:不是原来那个Promise实例).因此可以采用链式写法,then后面调用另一个then方法
-


```js
// Promise 实例
(() => {
  const f1 = async () => {
    const res = await new Promise((resolve) => {
      setTimeout(() => { resolve('p1'); }, 1000);
    });
    return [res, 'p2'];
  };
  f1().then(res => {
    console.log(res);
  }).catch(err => {
    console.log(err)
  });
})();

// Promise.all 实例
(() => {
  const p1 = new Promise((resolve, reject) => {
    setTimeout(() => { resolve('p1'); }, 1000);
  });
  const p2 = new Promise((resolve, reject) => {
    setTimeout(() => { resolve('p2'); }, 1000);
  });
  const f1 = async () => {
    const res = await Promise.all([p1, p2]);
    res.push('p3');
    return res;
  };
  f1().then(res => {
    console.log(res);
  }).catch(err => {
    console.log(err)
  });
})();
```


```js
let promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve([1, 2, 3])
  }, 1000)
}).then(res => {
  console.log(res)
}).catch(res => {
  console.log(res)
}).finally(() => {
  console.log('finally')
})
```

// Promise.resolve(value)方法返回一个以给定值解析后的Promise对象
```js
let promise2 = Promise.resolve([1, 2, 3]).then(res => {
  console.log(res)
}).catch(res => {
  console.log(res)
}).finally(() => {
  console.log('finally')
})
```

// Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）
```js
Promise.all([promise1, promise2]).then(res => {
  console.log('then')
}).catch(res => {
  console.log('catch')
})
```

// Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。
```js
Promise.race([promise1, promise2]).then(res => {
  console.log('then')
}).catch(res => {
  console.log('catch')
})
```

// 链式调用
```js
Promise.resolve('hello').then(res => {
  return new Promise((resolve, reject) => {
    setTimeout(() => { resolve(res + ' word') }, 1000)
  })
}).then(res => {
  console.log(res)
})
```

// 优先级
// setTimeout: 下一轮"事件循环"开始时执行
// Promise.resolve(): 本轮"事件循环"结束时执行
// console.log: 立即执行
```js
setTimeout(() => {
  console.log(3)
}, 0);

Promise.resolve().then(() => {
  console.log(2)
})

for (let i = 0; i < 10000; i++) {
  console.log(1)
}
```

### 例
- 循环 同步 Promise
```js
(async () => {
  for (let i = 1; i <= 10; i++) {
    await new Promise((resolve) => {
      setTimeout(() => {
        console.log(i);
        resolve();
      }, 1000);
    });
  }
})();
```
```js
// 无效,非同步,forEach里的函数只是参数
(() => {
  [1, 2, 3, 4].forEach(async v => {
    await new Promise((resolve) => {
      setTimeout(() => {
        console.log(v);
        resolve();
      }, 1000);
    });
  });
})();
```