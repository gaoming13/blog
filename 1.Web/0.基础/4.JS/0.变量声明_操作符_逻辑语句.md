## 目录
1. 变量声明
2. 操作符
3. 语句
4. 原始值与引用值
5. 执行上下文与作用域

### 变量声明
1. var
  1. 声明的是 函数作用域
    ```js
    for (var i = 0; i < 2; i++) {
      setTimeout(() => console.log(i)); // 2 2
    }
    console.log(i); // 2
    ```
  2. 存在声明提升(变量提升)：就是把 所有的变量声明 都拉到 *函数作用域的顶部*
    ```js
    function foo() { console.log(age); var age = 26; } foo(); // undefined
    console.log(age); // Uncaught ReferenceError: age is not defined
    // 等价于
    function foo() { var age; console.log(age); age = 26; } foo();

    console.log(color); // undefined
    if (true) { var color = 'red'; }
    console.log(color); // undefined
    // 等价于
    var color;
    console.log(color);
    if (true) { color = 'red'; }
    ```
  3. 全局声明：在 全局作用域 内声明的变量会成为 window 对象的属性
  4. 反复多次使用 var 声明同一个变量也没有问题
2. let
  1. 声明的是 块作用域
    ```js
    for (let i = 0; i < 2; i++) {
      setTimeout(() => console.log(i)); // 0 1
    }
    console.log(i); // Uncaught ReferenceError: i is not defined

    if(true){ let x = 10; } console.log(x); // Uncaught ReferenceError: x is not defined
    ```
  2. 暂时性死区：在let声明之前的执行瞬间被成为 "暂时性死区"(temporal dead zone)
    - 由于let声明的变量不会在作用域内被提升，在此阶段引用任何后面才声明的变量都会抛出 ReferenceError
    ```js
    console.log(t2); // Uncaught ReferenceError: t2 is not defined
    console.log(t1); // Uncaught ReferenceError: Cannot access 't1' before initialization
    let t1 = 123;
    ```
  3. 与 var 关键词不同，使用 let 在全局作用域内声明的变量不会成为 window 对象的属性
  4. 不允许同一作用域内冗余声明
    ```js
    let age; let age; // Uncaught SyntaxError: Identifier 'age' has already been declared
    ```
3. const
  - 行为与let基本相同，唯一的区别是 const声明变量时*必须同时初始化变量*，且 *尝试修改 const声明变量会报错*
  - 不能修改的限制 *只是适用于 它指向的变量的引用*，对象属性 与 数组内值 不受只读保护

### 操作符
- 1.一元操作符
  - 增加/递减操作符： `x++` `++x` `x--` `--x`
  - 一元加和减：`-'3'` `+'3'` 对于非数值，则执行与 Number() 相同的转换
  - delete 删除对象属性 `delete obj.prop1`
  - typeof
  - void 表明一个运算没有返回值 `javascript:void(0)`
- 2.位操作符
  - 原码: 对数字的二进制表示，最高位为符号位，其余位表示数值大小: 10010010 -> -18
  - 反码: 正数的反码与原码相同;负数的反码是全部取反,符号位不变: 11101101 -> -18 反码
  - 补码: 正数的补码与原码相同;负数的补码是全部取反+1,符号位不变: 11101110 -> -18 补码
  - ECMAScript 中的所有数值都以 IEEE 754 64位格式存储，但位操作并不直接应用到64位表示
    - 而是先把值转换为 32位 整数，再进行位操作，之后再把结果转换成 64位
    - 对于开发者而言，64位 整数存储格式是不可见的，就好像只有 32位 整数一样
  - 有符号整数使用32位：*{1:符号位(0正1负)}{31:整数值}*
    - 正值以真正的二进制格式存储：
      - 00000000 00000000 00000000 00010010 -> 18
    - 负值以补码的二进制格式存储
      - 11111111 11111111 11111111 11101101 -> 取反
      - 11111111 11111111 11111111 11101110 -> 取反 + 1 -> 补码 -> -18
  - 若将位操作符应用到非数值：那么首先会自动使用 Number() 函数转换为 数值，然后再应用位操作
  - 按位 非(NOT) `~a`
    - 规则：按小数点对调所有位(~a = -a - 1)
    - 32位存储
      - 1. 00000000 00000000 00000000 00000101 -> 5
      - 2. 11111111 11111111 11111111 11111010 -> 按位取反
    - 读取值
      - 3. 00000000 00000000 00000000 00000101 -> 取反
      - 4. 00000000 00000000 00000000 00000110 -> 取反+1 -> -6
  - 按位 与(AND) `a&b`
    - 规则：`1 && 1 ? 1 : 0`
  - 按位 或(OR) `a|b`
    - 规则：`(1 && 0) || (0 && 1) || (1 && 1) ? 1 : 0`
    - 应用：
  - 按位 异或(XOR) `a^b`
    - 规则：`(1 && 0) || (0 && 1) ? 1 : 0`  例子：`12^5=9`
  - 左移 `a<<1` 将数值的所有32位都向左移，同时保留符号（正或负），空位补0
    - 例: 2<<9 == 2**10
  - 有符号右移 `a>>1` 将数值的所有32位都向右移，同时保留符号（正或负），空位补0
    - 例：64>>2 == 16, -64>>2 == -16
  - 无符号右移 `a>>>1` 不保留符号
    - 例：64>>>2,  -64>>>2 == 1073741808
  - 应用1: 类似于parseInt,但转换不了的都变成了0
    - 方法：x|0, x&-1, x^0, ~~x, x<<0, x>>0
    - `'12.933' | 0` -> 12, `'12.23sdf' | 0` -> 0
  - 应用2: 位开关，一个变量表示3个灯泡的状态(二种状态)
    ```js
    ((st) => {
      const l1 = (st&1) == 1;
      const l2 = (st&2) == 2;
      const l3 = (st&4) == 4;
    })(1|4);
    // 1和3是否都开着: st & (1|4) == (1|4)
    ```
  - 应用3: 交换2个数
    ```js
    // 表达式方式
    a = [b, b = a][0];
    // 异或
    a ^= b; b ^= a; a ^= b;
    ```
- 3. 布尔操作符(逻辑非/逻辑与/逻辑或) `&&` `||` `!`
- 4. 乘性操作符(乘法/除法/取摸) `*` `/` `%`
- 5. 指数操作符 `2**3` 8 `10**-1` 0.1
- 6. 条件(三元)操作符 `条件 ? 值1:值2`
- 7. 赋值操作符(Assignment operator) `x=y` `x+=y` ...
  - 解构 `let [v1, v2, v3]=[1, 2, 3]`
- 8. 逗号操作符 `let a = 1, b = 2, c = 3;`
- 9. 关系操作符
  - in 如果指定的属性存在于所指定的对象中,则返回true `prop1 in obj`
  - instanceof 判断对象是否是指定的类型 `obj1 instanceof ojd`

### 语句
- 标签语句
  ```js
  label1:
  for (var i = 0; i < 100; i++) {
    label2:
    for (var j = 0; j < 100; j++) {
      if (i === 5) continue label2; // 停止本次循环,跳转到label1下的循环继续
      if (i === 3) break label1; // 停止本次循环,跳出到label1下的循环
    }
  }
  ```
- with 语句 - 用途是将代码作用域设置为特定的对象
  - 严格模式下不允许使用
  ```js
  const userArr = [{no:'1',name:'王二'},{no:'2',name:'李三'}];
  for (const user of userArr) {
    with (user) {
      // 可以少些一些代码
      console.log({no, name});
    }
  }
  ```
- for...in:
  - 迭代内容：以任意顺序遍历对象的除Symbol以外的可枚举属性名；
    - 不应该用于迭代一个Array,不能保证索引顺序
    - 仅迭代自身的属性，只考虑对象本身的属性，而不是它的原型：Object.getOwnPropertyNames(obj) 或 obj.hasOwnProperty('a')
  - 跳出循环: `break / throw / continue / return`
  ```js
  var obj = {a:1, b:2}; function C() { this.c = '3'; }; C.prototype = obj; var obj1 = new C();
  for (var i in obj1) { if (obj1.hasOwnProperty(i)) console.log(i); } // c

  let obj = {a: 1, b: 2}; obj.__proto__.c = 3;
  for (let i in obj) { console.log(i); } // a b c
  ```
- for...of:
  - 迭代内容：(Array、Map、Set、String、TypedArray、arguments)上创建一个迭代循环；
    - `arr.__proto__[Symbol.iterator]` 决定要迭代内容
  - 跳出循环: `break / throw / continue / return`
  - 迭代Array: `for (let v of [1, 2, 3]) { console.log(v) }`
  - 迭代String: `for (let v of 'abc') { console.log(v) }`
  - 迭代TypedArray: `for (let v of (new Uint8Array([0x00, 0xff]))) { console.log(v) }`
  - 迭代Map: `for (let [k, v] of (new Map([['a', 1]]))) { console.log({k, v}) }`
  - 迭代Set: `for (let v of (new Set([1, 2, 3]))) { console.log(v) }`
  - 迭代arguments `(function() { for (let v of arguments) { console.log(v) } })(1, 2, 3);`
  - 迭代DOM集合 `for (let v of document.querySelectorAll('p')) { console.log(v) }`
  - 迭代生成器 `function* f() { i = 0; while(true) { i += 1; yield(i); } }; for (let v of f()) { console.log(v) }`

### 函数
- 包含 函数声明 与 函数表达式
  - 函数声明 `function f1() {}`
  - 函数表达式 `const f1 = function f2() { console.log(f1 === f2); }` // 在函数体内 f1 与 f2 等价
  - 函数表单式(匿名) `const f1 = function() {}`
- 函数提升
  - 函数声明,有函数提升 `f1(); function f1(){}` OK
  - 函数表达式,没函数提升 `f1(); var f1 = function(){}` ERROR(f2 is not a function)
- 函数改变外部变量值
  - 基础数据类型作为参数传给函数，函数改变了这个参数，外部变量不变 `function f1(v){v=1;}; let a=0; f1(a);` a=0
  - 对象作为参数传给函数，函数改变了这个参数的属性，外部变量也会变 `function f1(v){v.push(1);}; let a=[]; f1(a);` a=[1]
- 函数参数
  - 函数的实际参数保存在一个类似数组的 arguments 对象中 `function f() { for (const v of arguments) { console.log(v); } }; f(1, 2, 3);`
  - 默认参数(es6) `function f(a = 0) {}`
  - 剩余参数(es6) `function f(a, ...b) {}`
- 闭包: 当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了
  - 内部函数只能在外部函数中访问
  - 内部函数形成了一个闭包：内部函数可以访问外部函数的参数和变量，但外部函数却不能使用它的参数和变量
  ```js
  // 闭包1
  (function() {})();
  function out(x, y) {
    function in(x) { return x * x; }
    return in(x) + in(y);
  }
  // 闭包2
  function pet(name) {
    let sex = '';
    return {
      getSex: () => sex,
      setSex: (sex) => { sex = sex },
      getName: () => name,
    };
  };
  const dog = pet('dog');
  dog.getName();
  dog.setSex('girl');
  dog.getSex();
  ```