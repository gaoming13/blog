> https://muyiy.cn/blog/4/4.1.html#%E4%B8%80%E3%80%81%E8%B5%8B%E5%80%BC%EF%BC%88copy%EF%BC%89
### 拷贝分类
1. 复制（Copy） - 将数值或对象赋给某个变量
  1. 基本数据类型：互不影响
  2. 引用数据类型：两个变量指向同一对象，相互影响
  ```js
  // obj1 -> {a:1, b: {c: 3}} <- obj2// obj1 -> {a:1, b: {c: 3}} <- obj2
  const obj1 = {a:1, b: {c: 3}};
  const obj2 = obj1;
  ```
2. 浅拷贝（Shallow Copy）
  - 对象属性是基本类型，拷贝的是基本数据类型；
  - 对象属性是引用类型，拷贝的就算是内存地址；
  - 只解决了第一层问题
  ```js
  // obj1.a -> 1, obj2.a -> 1
  // obj1.b -> {c: 3} <- obj2.b
  const obj1 = {a:1, b: {c: 3}};
  const obj2 = Object.assign({}, obj1);
  // 展开语法
  const obj2 = {...obj1};
  // slice
  const obj1 = [1, 2, [3, 4]];
  const obj2 = obj1.slice(0);
  ```
3. 深拷贝 (Deep Copy)
  - 深拷贝相比浅拷贝速度较慢且花销大，拷贝前后2个变量互不影响
  ```js
  // obj1 -> {a:1, b: {c: 3}}, obj2 -> {a:1, b: {c: 3}}
  const obj1 = {a:1, b: {c: 3}};
  const obj2 = JSON.parse(JSON.stringify(obj1));
  // 问题1：undefined、symbol、函数 会直接忽略
  JSON.stringify({e: undefined, f: Symbol('gm'), g: function() {}}); // {}
  // 问题2：循环引用会报错
  // 问题3：new Date，转换结果格式不一致
  new Date(); // Fri Mar 19 2021 11:57:53 GMT+0800 (中国标准时间)
  JSON.stringify({d: new Date()}); // {"d":"2021-03-19T03:57:53.036Z"}
  // 问题4：正则变成了 {}
  JSON.stringify({reg: /[0-9]{4}/}); // {"reg":{}}
  ```

### 自己实现 浅拷贝
```js
// 简单版
function cloneShallow(source) {
  if (source == null) return source;
  var to = Array.isArray(source) ? [] : {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      to[key] = source[key];
    }
  }
  return to;
}
```

### 自己实现 Object.assign
> https://muyiy.cn/blog/4/4.2.html#object-assign-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0
```js
// 完全匹配版
if (typeof Object.assign2 !== 'function') {
  Object.defineProperty(Object, 'assign2', {
    value: function (target) {
      // 参考：Object.assign('abc', {1: 'd'}) // VM5882:1 Uncaught TypeError: Cannot assign to read only property '1' of object '[object String]'
      // 由于 Object('abc') 属性描述符为不可写，即：writable: false
      // 但，js只会静默报错(silently failed)，在严格模式才会提示错误
      'use strict';
      // 或者 target == null
      if (target === null || target === undefined) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      // 原始类型被包装成对象
      // 参考：Object.assign('abc', {a: 1}) // String {"abc", a: 1}
      // 因此：模拟该效果，需要使用 Object(...)
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        // 或者 source == null
        if (source !== null && source !== undefined) {
          // 自身+原型链,仅枚举的
          for (var key in source) {
            // 自身的
            // 可能遇到 Object.create(null, {a: 1}) 无原型的对象，也就没有 hasOwnProperty 方法
            // 因此使用 Function 的构造函数方法 call 调用 Object的原型方法
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              to[key] = source[key];
            }
          }
        }
      }
      return to;
    },
    // 原生情况下挂载在 Object 上的属性都是不可枚举的，所以此处设置 enumrable: false
    // 判断属性是否可枚举
    // 1.Object.getOwnPropertyDescriptors(Object)
    // 2.Object.propertyIsEnumerable
    enumerable: false,
    writable: true,
    configurable: true,
  });
}
```

### 自己实现深拷贝
```js
// 深拷贝：不支持循环引用
function cloneDeep1(source, uniqueList = []) {
  if (source == null) return source;

  var to = Array.isArray(source) ? [] : {};

  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (typeof source[key] === 'object' && source[key] !== null) {
        to[key] = cloneDeep1(source[key], uniqueList);
      } else {
        to[key] = source[key];
      }
    }
  }
  return to;
}

// 深拷贝：支持循环引用 - 使用Map
function cloneDeep2(source, hash = new WeakMap()) {
  if (source == null) return source;

  var to = Array.isArray(source) ? [] : {};

  if (hash.has(source)) return hash.get(source); // 新增
  hash.set(source, to); // 新增

  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (typeof source[key] === 'object' && source[key] !== null) {
        to[key] = cloneDeep2(source[key], hash); // 修改
      } else {
        to[key] = source[key];
      }
    }
  }
  return to;
}

// 深拷贝：支持循环引用 - 使用数组
function cloneDeep3(source, uniqueList = []) {
  if (source == null) return source;

  var to = Array.isArray(source) ? [] : {};

  for (const v of uniqueList) {  // 新增
    if (v.source === source) return v.to; // 新增
  }
  uniqueList.push({source, to}); // 新增

  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (typeof source[key] === 'object' && source[key] !== null) {
        to[key] = cloneDeep3(source[key], uniqueList); // 修改
      } else {
        to[key] = source[key];
      }
    }
  }
  return to;
}
```




  - $.extend(true, {}, obj) // 第一个参数为 true 表示深拷贝, 无法拷贝 defineProperty
  - _.cloneDeep(obj1) // lodash 实现深拷贝, 无法拷贝 defineProperty



  ```js
  function _deepClone(source) {
    if (typeof source !== 'object') {
      return source;
    }
    let target = Array.isArray(source) ? [] : {};
    for (const key in source) {
      console.log(key);
      if (source.hasOwnProperty(key)) {
        if (typeof source[key] === 'object') {
          target[key] = deepClone(source[key]);
        } else {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  ```