## JavaScript 标准内置对象、以及它们它们的方法和属性
- 这里的 标准内置对象 不应与 全局对象(Global Object) 混淆
- 全局对象的属性 = 标准内置对象 + 用户脚本创建的 + 宿主程序提供的
  - 浏览器中: window / self / frames 是全局对象
  - Node.js 中: global 是全局对象
  - Web Workers 中: self 是全局变量
  - 在松散模式下，可以在函数中返回 this 来获取全局变量，但严格模式下和模块环境下，this 会返回 undefined
  - globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）

## 标准内置对象分类
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN

### 值
1. Infinity 一个数值，表示无穷大
  ```js
  console.log(Infinity); /* Infinity */
  console.log(Infinity + 1); /* Infinity */
  console.log(Infinity + 1 === Infinity); /* true */
  console.log(Math.pow(10, 1000)); /* Infinity */
  console.log(Math.log(0)); /* -Infinity */
  console.log(1 / Infinity); /* 0 */
  if (! isFinite(x)) {}
  isFinite(null); // true
  Number.isFinite(null); // false 可靠检测
  ```
2. NaN
  - NaN 不等于自身
  ```js
  console.log(NaN === NaN); // false
  console.log(Number.NaN === NaN); // false
  console.log(isNaN(NaN)); // true
  console.log(isNaN(Number.NaN)); // true
  ```
  - isNaN()：如果当前值是 NaN 或将其强制转化成数字后是 NaN，则返回 true
  - Number.isNaN()：如果当前值是 NaN，则返回 true
  ```js
  isNaN('hello'); // true
  Number.isNaN('hello'); // false 可靠检测
  ```
3. undefined
  - 判断一个属性是否定义,不会抛出未声明的错误
  ```js
  console.log(typeof obj.p1 === 'undefined');
  console.log(p1 in obj);
  ```
4. globalThis 标准方式获取全局对象

### 函数
1. eval
  - 第三方代码可以看到 eval() 被调用时的作用域，可能导致不同方式的攻击
  ```js
  // 慢，浏览器需要全局查询 Date 变量
  // 立刻执行
  eval('console.log(Date.now())');
  // 只需查询全局和函数体内的变量
  // 返回的是函数,调用后才开始执行
  (Function('console.log(Date.now())'))();
  ```
2. isFinite 是否为有限数值
  ```js
  isFinite(Infinity); // false
  isFinite(NaN); // false
  isFinite(2e64); // true
  // 会自动转化
  isFinite(null); // true
  Number.isFinite(null); // false 可靠检测
  ```
3. isNaN 是否为 NaN
  - 怪异行为：如果 isNaN 函数的参数不是 Number 类型，isNaN 函数会首先尝试将这个参数转换为数值，再判断
  ```js
  isNaN('hello'); // true
  Number.isNaN('hello'); // false 可靠检测
  // isNaN 的polyfill 可理解为
  var isNaN = function (value) {
    var n = Number(value);
    return n !== n;
  }
  // 怪异行为的利用
  function add(x) {
    if (isNaN(x)) x = 0;
    return x + 1;
  }
  function add(x) {
    if (Number.isNaN(Number(x))) x = 0;
    return x + 1;
  }
  ```
4. parseFloat 解析成浮点数
5. parseInt 解析成整数,向下取整(floor)
  ```js
  parseInt('0xF'); // 15
  parseInt('F', 16); // 15
  parseInt('015', 10); // 10
  parseInt('435', 2); // NaN
  // 严格解析函数
  function filterInt (value) {
    return (/^(\-|\+)?([0-9]+|Infinity)$/.test(value)) ? Number(value) : NaN;
  }
  ```
6. decodeURI 包含无效字符序列，会引发 URIError 异常
7. decodeURIComponent 包含无效字符序列，会引发 URIError 异常
8. encodeURI
  - 不转义的字符 `[A-Za-z0-9-_.!~*'()]#;,/?:@&=+$`
  - 其余 UTF-8 转义
  ```js
  encodeURI('http://example.com/?s=王');
  // http://example.com/?s=%E7%8E%8B
  ```
9. encodeURIComponent
  - 不转义的字符 `[A-Za-z0-9-_.!~*'()]`
  - 其余 UTF-8 转义
  ```js
  encodeURIComponent('http://example.com/?s=王');
  // http%3A%2F%2Fexample.com%2F%3Fs%3D%E7%8E%8B
  ```

### 对象:基本
1. Object
  - 构造函数：为给定值创建一个对象包装器
  - 以非构造函数形式调用时，Object 的行为等同于 new Object()
  ```js
  // 等价于 o = new Boolean(true);
  let o = new Object(true);
  ```
  - Object构造函数的方法
    - 1. Object.assign 通过复制一个或多个对象来创建一个新对象
    - 2. Object.create 指定原型对象和属性创建一个新对象
    - 3. Object.defineProperty 给对象添加一个属性
    - 4. Object.defineProperties 给对象添加多个属性
      ```js
      const obj = {
        p1: 1,
        get p2() { return this.p1 + 1; },
        set p3(x) { this.p1 = x * 2 },
      };
      Object.defineProperty(obj, 'p4', {
        get: function() { return this.p1; },
        set: function(x) { this.p1 = x + 1 },
      });
      Object.defineProperties(obj, {
        'p5': { get: function() { return 3; } },
        'p6': { get: function() { return 4; } },
      });
      ```
    - 5. Object.entries (自身可枚举)
    - 6. Object.freeze 冻结对象，其它代码不能删除或更改任何属性
    - 7. Object.getOwnPropertyDescriptor (自身可枚举 + 自身不可枚举)
    - 8. Object.getOwnPropertyNames (自身可枚举 + 自身不可枚举)
    - 9. Object.getOwnPropertySymbols (自身可枚举 + 自身不可枚举)
    - 10. Object.getPrototypeOf 返回指定对象的原型对象
    - 11. Object.is 比较两个值是否相同，所有NaN值都相等(与 == 和 === 不同)
    - 12. Object.isExtensible 判断对象是否可扩展
    - 13. Object.isFrozen 判断对象是否已经冻结
    - 14. Object.isSealed 判断对象是否已经密封
    - 15. Object.keys (自身可枚举)(数组的key会变成字符串)
    - 16. Object.preventExtensions 防止对象的任何扩展
    - 17. Object.seal 防止其它代码删除对象的属性
    - 18. Object.setPrototypeOf 设置对象的原型
    - 19. Object.values 返回一个数组，包含自身可枚举的值
  - Object实例 和 Object原型对象
    - Object.prototype.hasOwnProperty 返回一个布尔值，表示对象自身是否含有指定属性
    - Object.prototype.isPrototypeof 返回一个布尔值，表示对象是否在原型链中
    - Object.prototype.toString
    - Object.prototype.valueOf 返回指定对象的原始值
  - 如何遍历属性
    1. Object.keys (自身可枚举)
    2. Objeect.getOwnPropertyNames (自身可枚举 + 自身不可枚举)
    3. for key in obj (自身可枚举 + 原型链可枚举)
    ```js
    const arr = ['a', 'b'];
    arr.p1 = '123';
    Object.prototype.p2 = '456';
    // 注：数组的key会变成字符串
    Object.keys(arr); // ["0", "1", "p1"]
    Object.getOwnPropertyNames(arr); // ["0", "1", "length", "p1"]
    for (const k in arr) { console.log(k); } // 0 1 p1 p2
    ```
  - 判断属性是否存在
    1. obj.hasOwnProperty (自身)
    2. 'a' in obj (自身+原型链 && 仅可枚举)
  - 删除属性
    1. delete obj.a
2. Function
3. Boolean
4. Symbol

### 对象:错误
- Error
- AggregateError
- EvalError
- InternalError
- RangeError
- ReferenceError
- SyntaxError
- TypeError
- URIError

### 对象:数字和日期
- Number
- BigInt
- Math
- Date

### 对象:字符串
- String
- RegExp

### 对象:数组
- Array
- Int8Array
- Uint8Array
- Uint8ClampedArray
- Int16Array
- Uint16Array
- Int32Array
- Uint32Array
- Float32Array
- Float64Array
- BigInt64Array
- BigUint64Array

### 对象:集合
- Map
- Set
- WeakMap
- WeakSet

### 对象:结构化
- ArrayBuffer
- SharedArrayBuffer
- Atomics
- DataView
- JSON

### 对象:控制抽象
Promise
Generator
GeneratorFunction
AsyncFunction

### 对象:反射
Reflect
Proxy

### 对象:国际化
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.ListFormat
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Locale

### 对象:WebAssembly
WebAssembly
WebAssembly.Module
WebAssembly.Instance
WebAssembly.Memory
WebAssembly.Table
WebAssembly.CompileError
WebAssembly.LinkError (en-US)
WebAssembly.RuntimeError