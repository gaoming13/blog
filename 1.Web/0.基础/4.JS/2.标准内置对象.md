## JavaScript 标准内置对象、以及它们它们的方法和属性
- 这里的 标准内置对象 不应与 全局对象(Global Object) 混淆
- 全局对象的属性 = 标准内置对象 + 用户脚本创建的 + 宿主程序提供的
  - 浏览器中: window / self / frames 是全局对象
  - Node.js 中: global 是全局对象
  - Web Workers 中: self 是全局变量
  - 在松散模式下，可以在函数中返回 this 来获取全局变量，但严格模式下和模块环境下，this 会返回 undefined
  - globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）

## 标准内置对象分类
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN
- Global对象的函数
  - eval
  - isFinite
  - isNaN
  - parseFloat
  - parseInt
  - decodeURI
  - decodeURIComponent
  - encodeURI
  - encodeURIComponent
- 对象:基本
  - Object
  - Function
  - Boolean
  - Symbol
- 对象:错误
  - Error
  - AggregateError
  - EvalError
  - InternalError
  - RangeError
  - ReferenceError
  - SyntaxError
  - TypeError
  - URIError
- 对象:数字和日期
  - Number
  - BigInt
  - Math
  - Date
- 对象:字符串
  - String
  - RegExp
- 对象:数组
  - Array
  - Int8Array
  - Uint8Array
  - Uint8ClampedArray
  - Int16Array
  - Uint16Array
  - Int32Array
  - Uint32Array
  - Float32Array
  - Float64Array
  - BigInt64Array
  - BigUint64Array
- 对象:集合
  - Map
  - Set
  - WeakMap
  - WeakSet
- 对象:结构化
  - ArrayBuffer
  - SharedArrayBuffer
  - Atomics
  - DataView
  - JSON
- 对象:控制抽象
  - Promise
  - Generator
  - GeneratorFunction
  - AsyncFunction
- 对象:反射
  - Reflect
  - Proxy
- 对象:国际化
  - Intl
  - Intl.Collator
  - Intl.DateTimeFormat
  - Intl.ListFormat
  - Intl.NumberFormat
  - Intl.PluralRules
  - Intl.RelativeTimeFormat
  - Intl.Locale
- 对象:WebAssembly
  - WebAssembly
  - WebAssembly.Module
  - WebAssembly.Instance
  - WebAssembly.Memory
  - WebAssembly.Table
  - WebAssembly.CompileError
  - WebAssembly.LinkError (en-US)
  - WebAssembly.RuntimeError

### eval
- 第三方代码可以看到 eval() 被调用时的作用域，可能导致不同方式的攻击
```js
// 慢，浏览器需要全局查询 Date 变量
// 立刻执行
eval('console.log(Date.now())');
// 只需查询全局和函数体内的变量
// 返回的是函数,调用后才开始执行
(Function('console.log(Date.now())'))();
```

### isFinite
- 是否为有限数值
```js
isFinite(Infinity); // false
isFinite(NaN); // false
isFinite(2e64); // true
// 会自动转化
isFinite(null); // true
Number.isFinite(null); // false 可靠检测
```

### isNaN
- 是否为 NaN
- 怪异行为：如果 isNaN 函数的参数不是 Number 类型，isNaN 函数会首先尝试将这个参数转换为数值，再判断
```js
isNaN('hello'); // true
Number.isNaN('hello'); // false 可靠检测
// isNaN 的polyfill 可理解为
var isNaN = function (value) {
  var n = Number(value);
  return n !== n;
}
// 怪异行为的利用
function add(x) {
  if (isNaN(x)) x = 0;
  return x + 1;
}
function add(x) {
  if (Number.isNaN(Number(x))) x = 0;
  return x + 1;
}
```

### parseFloat
- 解析成浮点数

### parseInt
- 解析成整数,向下取整(floor)
```js
parseInt('0xF'); // 15
parseInt('F', 16); // 15
parseInt('015', 10); // 10
parseInt('435', 2); // NaN
// 严格解析函数
function filterInt (value) {
  return (/^(\-|\+)?([0-9]+|Infinity)$/.test(value)) ? Number(value) : NaN;
}
```

### decodeURI
- 包含无效字符序列，会引发 URIError 异常

### decodeURIComponent
- 包含无效字符序列，会引发 URIError 异常

### encodeURI
- 不转义的字符 `[A-Za-z0-9-_.!~*'()]#;,/?:@&=+$`
- 其余 UTF-8 转义
```js
encodeURI('http://example.com/?s=王');
// http://example.com/?s=%E7%8E%8B
```

### encodeURIComponent
- 不转义的字符 `[A-Za-z0-9-_.!~*'()]`
- 其余 UTF-8 转义
```js
encodeURIComponent('http://example.com/?s=王');
// http%3A%2F%2Fexample.com%2F%3Fs%3D%E7%8E%8B
```

### Object
- 构造函数：为给定值创建一个对象包装器
- 以非构造函数形式调用时，Object 的行为等同于 new Object()
```js
// 等价于 o = new Boolean(true);
let o = new Object(true);
```
- Object构造函数的方法
  - 1. Object.assign 通过复制一个或多个对象来创建一个新对象
  - 2. Object.create 指定原型对象和属性创建一个新对象
  - 3. Object.defineProperty 给对象添加一个属性
  - 4. Object.defineProperties 给对象添加多个属性
    ```js
    const obj = {
      p1: 1,
      get p2() { return this.p1 + 1; },
      set p3(x) { this.p1 = x * 2 },
    };
    Object.defineProperty(obj, 'p4', {
      get: function() { return this.p1; },
      set: function(x) { this.p1 = x + 1 },
    });
    Object.defineProperties(obj, {
      'p5': { get: function() { return 3; } },
      'p6': { get: function() { return 4; } },
    });
    ```
  - 5. Object.entries (自身可枚举)
  - 6. Object.freeze 冻结对象，其它代码不能删除或更改任何属性
  - 7. Object.getOwnPropertyDescriptor (自身可枚举 + 自身不可枚举)
  - 8. Object.getOwnPropertyNames (自身可枚举 + 自身不可枚举)
  - 9. Object.getOwnPropertySymbols (自身可枚举 + 自身不可枚举)
  - 10. Object.getPrototypeOf 返回指定对象的原型对象
  - 11. Object.is 比较两个值是否相同，所有NaN值都相等(与 == 和 === 不同)
  - 12. Object.isExtensible 判断对象是否可扩展
  - 13. Object.isFrozen 判断对象是否已经冻结
  - 14. Object.isSealed 判断对象是否已经密封
  - 15. Object.keys (自身可枚举)(数组的key会变成字符串)
  - 16. Object.preventExtensions 防止对象的任何扩展
  - 17. Object.seal 防止其它代码删除对象的属性
  - 18. Object.setPrototypeOf 设置对象的原型
  - 19. Object.values 返回一个数组，包含自身可枚举的值
- Object实例 和 Object原型对象
  - Object.prototype.hasOwnProperty 返回一个布尔值，表示对象自身是否含有指定属性
  - Object.prototype.isPrototypeof 返回一个布尔值，表示对象是否在原型链中
  - Object.prototype.toString
  - Object.prototype.valueOf 返回指定对象的原始值
- 遍历属性 - 参见：img/遍历属性函数
  ```js
  const obj = ['a', 'b']; obj.p1 = 1; obj[Symbol('s1')] = 1;
  Object.prototype.p2 = 2; Object.prototype[Symbol('s2')] = 2;
  ```
  // 遍历次序规则：
  // 1.首先遍历所有数值键，按照数值升序排列。
  // 2.其次遍历所有字符串键，按照加入时间升序排列。
  // 3.最后遍历所有 Symbol 键，按照加入时间升序排列。
- 判断属性是否存在
  1. obj.hasOwnProperty (自身)
  2. 'a' in obj (自身+原型链 && 仅可枚举)
- 删除属性
  1. delete obj.a

### Function

### Boolean

### Symbol

### Error
### AggregateError
### EvalError
### InternalError
### RangeError
### ReferenceError
### SyntaxError
### TypeError
### URIError

### Number
- n.toString(进制)
- n.toFixed(小数位) 四舍五入
- n.toExponential(小数位) 科学计数形式
- Number.isInteger(12.00) // true

### BigInt

### Math对象
- Math.E 自然对数的基数e的值
- Math.LN2 2为底的自然对数
- Math.LN10 10为底的自然对数
- Math.LOG2E 以2为底e的对数
- Math.LOG10E 以10为底e的对数
- Math.PI π的值
- Math.SQRT1_2 1/2的平方根
- Math.SQRT2: 2的平方根
- Math.max
- Math.min
- Math.floor 向下取整
- Math.ceil 向上取整
- Math.round 四舍五入
- Math.fround 最接近的单精度(32位)浮点值表示
- Math.random
- Math.abs
- Math.exp(x) Math.E的x次幂
- Math.log(x) x的自然对数
- Math.pow(x, power) x的power次幂

### Date
- `Date.parse('2021-04-09T00:00:00.888')` 返回时间戳: 2021-04-09 00:00:00`
- `Date.UTC(2021, 3, 9, 0, 0, 0, 888)` 返回时间戳: 2021-04-09 08:00:00
- `Date.now()` 返回当前时间戳
- `const d1 = new Date(2021, 3, 9, 0, 0, 0, 888)` 2021-04-09 00:00:00
- `Date.prototype.toString()` 返回日期的字符串表示
- `Date.prototype.valueOf()` 返回日期的时间戳
- `Date.prototype.toISOString()` 返回 2021-04-09T07:02:39.355Z
- `Date.prototype.getTimezoneOffset()` 分钟计的UTC与本地时间的偏移量 -480

### String
- `s.length` 属性
- `String.fromCharCode(int)` ES5提供 String.fromCharCode() 无法正确识别码点大于 0xFFFF 的字符
- `String.fromCodePoint(int)` ES6的这个可以:Unicode码点->对应字符
- `String.raw`\u00A9` 还原模版字符串的处理方法
- `String.prototype.length` 按照16位,2B编码,大于2B,长度2
- `String.prototype.charAt(index)` 字符串指定索引(`0~length-1`)处的字符
- `String.prototype.charCodeAt(index)` 字符串指定索引(`0~length-1`)处的UTF-16编码单元体现的数字，范围 `0~65536`，`0x0000~0xffff`
- `String.prototype.codePointAt(index)` 字符串指定索引(`0~length-1`)处的编码单元体现的数字
- `String.prototype.indexOf(str)` `lastIndexOf(str)` 指定子串开始/结束的位置
- `String.prototype.concat(str)` 字符串拼接
- `String.prototype.split(str)` 字符串分割成数组
- `String.prototype.slice(beginIndex, endIndex)` 返回字符串切割的一部分(支持负值)
- `String.prototype.substring(indexStart, indexEnd)`
- `String.prototype.substr(indexStart, length)`
- `String.prototype.match` `replace` `search`
- `String.prototype.normalize(form)` 按照指定一种 Unicode 正规形式将字符串正规化
- `String.prototype.toUpperCase()` `toLowerCase()`
- `String.prototype.repeat(count)` 重复指定次数
- `String.prototype.trim()` 去除开头结尾的空白字符
- `String.prototype.includes()` 字符串搜索方法, 都支持第二个参数(开始搜索的位置)
- `String.prototype.startsWith()` 字符串搜索方法, 都支持第二个参数(开始搜索的位置)
- `String.prototype.endsWith()` 字符串搜索方法, 都支持第二个参数(开始搜索的位置)
- 新增了几个专门处理4字节码点的函数
  - `String.fromCodePoint()` Unicode码点->对应字符
  - `String.prototype.codePointAt()` 字符->对应的码点

### RegExp
- 通过 RegExp 类型支持正则表达式, 使用类似 Perl 的简洁语法来创建
  - `let r1 = /^.$/u;` */pattern/flags*
  - `let r1 = new RegExp('.', 'u');`
  - pattern(模式)可以是任何简单或复杂的正则表达式
  - 可以携带0个或多个 flags(标记),用于控制正则表达式的行为
  - 实例:
    ```js
    let s = '<a href="https://www.baidu.com/">王热砂</a>';
    console.log(s.match(/<a href="[^"]*">([^<]*)<\/a>/));
    ```
- 匹配模式的flags(标记)
  - g:全局模式 - 表示查找字符串的全部内容,而不是找到第一个匹配的内容就结束
  - i:不区分大小写 - 表示在超找匹配时忽略 pattern 和 字符串 的大小写
  - m:多行模式 - 表示查找到一行文本末尾时会继续查找
  - y:粘附模式 - 表示只查找从 lastIndex 开始及之后的字符串
  - u:Unicode模式 - 用来处理大于 \uFFFF 的Unicode 字符 `/\u{20BB7}/u.test('𠮷')`
  - s:dotAll模式 - 表示元字符.匹配任何字符(包括\n或\r)
- RegExp实例属性
  - r.global 布尔值，表示是否设置了 g 标记
  - r.ignoreCase 布尔值，表示是否设置了 i 标记
  - r.multiline 布尔值，表示是否设置了 m 标记
  - r.sticky 布尔值，表示是否设置了 y 标记
  - r.unicode 布尔值，表示是否设置了 u 标记
  - r.dotAll 布尔值，表示是否设置了 s 标记
  - r.lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始
  - r.source 实例的pattern,没有开头和结尾的斜杠
  - r.flags 实例的flags(标记)
- RegExp实例方法
  - r.exec()
    ```js
    let s = 'Hello,red! Hello,blue!';
    // 不用g的话,index始终是0
    let r = /Hello,([a-z]*)!/g;
    let res = r.exec(s);
    // 0: "Hello,red!" 1: "red" groups: undefined index: 0 input: "Hello,red! Hello,blue!"
    res = r.exec(s);
    // 0: "Hello,blue!" 1: "blue" groups: undefined index: 11 input: "Hello,red! Hello,blue!" length: 2
    res = r.exec(s);
    // null
    ```
  - r.test() 判断输入文本与模式是否匹配
- RegExp构造函数属性
  - 这些属性适用于作用域中的所有正则表达式,且会根据最后执行的正则表达式操作而变化
  - 可以通过2种不同的方式访问它们
  - RegExp.input, RegExp.$_ 最后搜索的字符串(非标准)
  - RegExp.lastMatch, RegExp.$& 最后匹配的文本
  - RegExp.lastParen, RegExp.$+ 最后匹配的捕获组(非标准)
  - RegExp.leftContext, RegExp.$` input字符串中出现在 lastMatch 前面的文本
  - RegExp.rightContext, RegExp.$' input字符串中出现在 lastMatch 后面的文本
  ```js
  /(.hort)/g.test('a short summer');
  console.log([
    RegExp.input, RegExp.$_, // "a short summer"
    RegExp.lastMatch, RegExp['$&'], // "short"
    RegExp.lastParen, RegExp['$+'], // "short"
    RegExp.leftContext, RegExp['$`'], // "a "
    RegExp.rightContext, RegExp['$\''], // " summer"
  ]);
  ```
- 字符串的正则方法(match、replace、search、split)
  - ES6将这四个方法,在语言内全部调用 RegExp 的实例方法,做到与正则相关的方法,都定义在RegExp对象上
  - String.prototype.math 调用 RegExp.prototype[Symbol.match]
  - String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
  - String.prototype.search 调用 RegExp.prototype[Symbol.search]
  - String.prototype.split 调用 RegExp.prototype[Symbol.split]
  ```js
  'abc'.replace({
    [Symbol.replace](searchVal, replaceVal) {
      return searchVal.replace('ab', replaceVal);
    }
  }, 'k'); // kc
  ```
- 匹配字符
  - `\`
    - 1.`\特殊字符` 表示转义,下一个字符应该按字面理解;
      - `string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")` // $&表示整个被匹配的字符串
    - 2.`\非特殊字符` 不能按字面理解
  - `^` 匹配输入的开始位置.
    - 如果多行标志被设置为 true, 那么也匹配换行符后紧跟的位置 Demo `/^abc/`
  - `$` 匹配输入的结束位置.
    - 如果多行标志被设置为 true, 那么也匹配换行符前的位置 Demo `/abc$/`
  - `*` 匹配前一个表达式0～n次. 等价于 `{0,}` Demo `/ab*c/`
  - `+` 匹配前一个表达式1～n次. 等价于 `{1,}` Demo: `/(ab)+c/.test('ababc')`
  - `?` 匹配前一个表达式0或1次. 等价于 `{0,1}` Demo: `/(ab)?c/.test('abc')`
    - 若紧跟在任何量词 `*、+、?、{}` 后面，将会使量词变为非贪婪(匹配尽量少的字符), 和缺省使用的贪婪模式相反
  - `.` 匹配除换行符之外的任何单个字符串
    - 如果 `s(dotAll)` 标志位被设为 true, 它也会匹配换行符
  - `(x)` 匹配 x 并记住匹配项. 其中括号称为捕获括号.
    - `/(lo|ld)/.exec('Hello World!')` 匹配一个
    - `[...'Hello World!'.match(/(lo|ld)/g)]` 匹配一个
    - `[...'Hello World!'.matchAll(/(lo|ld)/g)]` 匹配所有
    - `'Hello World!'.replace(/(lo|ld)/g, '-$1')` 替换所有
  - `(?:x)` 匹配 x 但是不记住匹配项. 这种括号称为非捕获括号.
  - `x(?=y)` 先行断言. 匹配x,仅当x后面是y Demo: `/Hello(?= World)/i.test('hello world')`
  - `(?<=y)x` 后行断言. 匹配x,仅当x前面是y
  - `x(?!y)` 正向否定查找. 仅当x后面不紧跟y时匹配x
  - `(?<!y)x` 反向否定查找. 仅当x前面不是y时匹配x
  - `x|y` 匹配x或y
  - `{n}` `{n,}` `{n,m}` 匹配前一个字符n～m次
  - `[xyz]` 匹配方括号中的任意字符，包括转义序列.
    - 可以使用破折号 `-` 来指定一个字符范围
    - 对于 `.、*` 这样的特殊符号无需转义
  - `[^xyz]` 匹配任何没有包含在方括号中的字符
  - `[\b]` 匹配一个退格(U+0008)
  - `\b` 匹配一个词的边界. 一个词的边界就是一个词不被另一个字符跟随的位置 `/hello\b/i.exec('Hello world')`
  - `\B` 匹配一个非单词边界. `/hell\B/i.exec('Hello world')`
  - `\cX` 当X是处于A到Z之间的字符的时候, 匹配字符串中的一个控制符 EG: `/\cM/ 匹配 contrl-M(U+000D)`
  - `\d` 匹配一个数字字符. 等价于 [0-9]
  - `\D` 匹配一个非数字字符. 等价于 [^0-9]
  - `\f` 匹配一个换页符(U+000C)
  - `\n` 匹配一个换行符(U+000A)
  - `\r` 匹配一个回车符(U+000D)
  - `\s` 匹配一个空白字符(包含 空格、制表符、换页符、换行符)
  - `\S` 匹配一个非空白字符
  - `\t` 匹配一个水平制表符(U+0009)
  - `\v` 匹配一个垂直制表符(U+000B)
  - `\w` 匹配一个单字字符(字母、数字、下划线). 等价于 `[A-Za-z0-9_]`
  - `\W` 匹配一个非单字字符. 等价于 `[A-Za-z0-9_]`
  - `\n` ???
  - `\0` 匹配 NULL(U+0000) 字符, 不要在这后面跟其它小数, 因为 `\0<digits>` 是一个八进制转义序列
  - `\xhh` 匹配一个两位十六进制数 (\x00-\xFF) 表示的字符
  - `\uhhhh` 匹配一个四位十六进制数表示的 UTF-16 代码单元
  - `\u{hhhh} 或 \u{hhhhh}` 匹配一个十六进制数表示的 Unicode字符

### Array
- 对象原型属性与方法
  - `Array.prototype.length` 修改length会影响数组的长度
  - `Array.prototype.toString()` 返回数组中每个值的等效字符串拼接成的一个逗号分隔的字符串
    ```js
    [['a', 'b'], 'c'].toString() // "a,b,c"
    ```
  - `Array.prototype.join(separator=',')` 连接成字符串,返回操作后的字符串
  - 操作方法
    - `Array.prototype.concat(...arr)` 合并,返回操作后的数组
      - Symbol.isConcatSpreadable 控制合并的时候是否打平/展开
    - `Array.prototype.slice(star, end)` 从数组中提取片段,返回数组片段
    - `Array.prototype.splice(index, countRemove[, ...ele])` 从数组中移除一些元素,并替换它们
  - 栈方法(LIFO后进先出)
    - `Array.prototype.push(...ele)` 末尾添加多个元素,返回操作后的长度
    - `Array.prototype.pop()` 末尾移除1个元素,返回该元素
  - 队列方法(FIFO先进先出)
    - `Array.prototype.push(...ele)` 末尾添加多个元素,返回操作后的长度
    - `Array.prototype.shift()` 头部移除1个元素,返回该元素
  - `Array.prototype.unshift(...ele)` 头部添加多个元素,返回操作后的长度
  - 搜索位置方法
    - `Array.prototype.indexOf(ele[, fromIndex])` 返回元素的索引
    - `Array.prototype.lastIndexOf(ele[, fromIndex])` 返回元素的索引,从结尾开始搜索
    - `Array.prototype.find()` 找出第一个符合条件的数组成员 // es6
    - `Array.prototype.findIndex()` 找出第一个符合条件的数组key // es6
    ```js
    const arr = ['a', 'b', 'c'];
    console.log(arr.find((val, index, obj) => {
      return false;
    }))
    ```
  - 排序方法(都返回调用它们数组的引用)
    - `Array.prototype.reverse()` 颠倒数组的顺序
    - `Array.prototype.sort(fn)` 数组排序,默认升序
      ```js
      const arr = [1, 2, 9, 4, 6];
      arr.sort((a, b) => b - a);
      ```
  - 复制、填充
    - `Array.prototype.fill()` 填充数组 // es6
      ```js
      let arr = Array(6); // [empty × 6]
      arr.fill(0); // [0, 0, 0, 0, 0, 0]
      arr.fill(1, 3); // [0, 0, 0, 1, 1, 1]
      arr.fill(2, 2, -2); // [0, 0, 2, 2, 1, 1]
      ```
    - `Array.prototype.copyWithin()` 复制替换 // es6
      ```js
      let arr = [1, 2, 3, 4, 5, 6];
      arr.copyWithin(3); // [1, 2, 3, 1, 2, 3]
      arr.copyWithin(4, 2); // [1, 2, 3, 1, 3, 1]
      ```
  - 遍历方法
    - `Array.prototype.entries()` // 遍历数组,[[k, v], [k, v]]
    - `Array.prototype.keys()` // 遍历数组 [k, k]
    - `Array.prototype.values()` // 遍历数组 [v, v]
  - 迭代方法
    - `Array.prototype.forEach(callback[, thisObject])` 在数组每个元素上执行callback
    - `Array.prototype.map(callback[, thisObject])` 遍历数组,callback对数组进行操作,并将结果写回数组
    - `Array.prototype.filter(callback[, thisObject])` 遍历数组,符合条件的返回true
    - `Array.prototype.every(callback[, thisObject])` 遍历数组,每项都返回true,则返回true
    - `Array.prototype.some(callback[, thisObject])` 遍历数组,有1项返回true,则返回true
  - 归并方法
    - `Array.prototype.reduce(callback[, thisObject])` 遍历数组, callback(firstVal, secondVal), 每2个计算一次, 返回总和
    - `Array.prototype.reduceRight(callback[, thisObject])` 右侧开始遍历
  - `Array.prototype.includes()` // 判断是否包含某给定值
  - `Array.prototype.flat()` // 将嵌套的数组拉平,变成一维数组
  - `Array.prototype.flatMap()` // 拉平遍历
- 构造函数静态方法
  - `Array.isArray()` 见：<3种判断数组的方法，介绍区别与优劣>
  - `Array.from()` 用于将2类对象转换为真正的数组
    - 1.类似数组的对象(array-like object)
    - 2.可遍历(iterable)的对象 (包括 Set 和 Map)
      ```js
      function f1() { console.log(Array.prototype.slice.call(arguments)); } f1(1, 2, 3);
      Array.from(arguments);
      Array.from('123456', function (v) { return v * this.cap }, { cap: 2 }); // [2, 4, 6, 8, 10, 12]
      const map1 = new Map(); map1.set('a', '1'); map1.set('b', '2');
      Array.form(map1); // [["a","1"],["b","2"]]
      ```
  - `Array.of()` 用于将一组值转换为数组
    ```js
    Array.of(1, 2, 3); // [1, 2, 3]
    ```
- 扩展运算符
  - 替代函数的apply方法
    - 由于扩展运算符可以展开数组,所以不再需要apply方法,将数组转换为参数了
    - function f(x, y) {}; f.apply(null, [1, 2]); // es5
    - function f(x, y) {}; f(...[1, 2]); // es6
  - 实现了 Iterator 接口的对象
    - *任何定了遍历器(Iterator)接口的对象,都可以用扩展运算符转换为真正的数组*
    ```js
    let a = {};
    a[Symbol.iterator] = function*(){
      for (let i = 1; i <= 3; i++) yield i;
    };
    [...a]
    ```
  - 合并2个数组
    ```js
    a.concat(b)
    for (const v of b) { a.push(v); }
    [...a, ...b] // es
    a.push(...b) // es
    Array.prototype.push.apply(a, b) // es
    ```
  - 复制数组
    ```js
    let b = a.concat()
    let b = [...a]
    let [...b] = a
    ```
  - 字符串长度
    - `[...'hello😄'].length` // 可以正确识别四个字节的unicode字符
    - 同 `Array.from('hell😄').length`
- 数组空位
  ```js
  Array.from(new Array(3)) // [undefined, undefined, undefined]
  Array.from([,,,]) // [undefined, undefined, undefined]
  ```
- 数组索引
  - 修改数组 `arr[100] = 1`,会自动修改数组的长度
  - 数组 length 属性是可以修改的,修改后,可直接改变数组的长度
- 已知如下数组，编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
  ```js
  var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
  Array.from(new Set(arr.toString().split(',')), v => Number(v)).sort((a, b) => b - a);
  [...new Set(arr.flat(Infinity))].sort((a, b) => b - a);
  ```

### 定型数组
- ArrayBuffer / SharedArrayBuffer
- DataView
- Int8Array / Uint8Array / Uint8ClampedArray
- Int16Array / Uint16Array
- Int32Array / Uint32Array
- Float32Array / Float64Array
- BigInt64Array / BigUint64Array
- 定型数组(typed array)是 ECMAScript 新增的结构,目的是提升向原生库传输数据的效率
- 2006年浏览器提供商期待开发一套 JS API,从而重复利用 3D图形API 和 GPU加速,以便在 canvas 元素上渲染复杂的图形
- 2011年发布 WebGL,因为 JS 数组与原生数组之间不匹配,出现了性能问题
- 为解决这个问题,实现了 CanvasFloatArray,最后变成了 Float32Array,也就是今天定型数组中可用的第一个类型
- `Float32Array` 是一种视图,允许js运行时访问一块名为 ArrayBuffer 的预分配内存
- ArrayBuffer
  - 是所有定型数组及视图引用的基本单位
  - SharedArrayBuffer 是 ArrayBuffer 的一个变体,可以无需复制就在执行上下文间传递它
  - ArrayBuffer 一经创建就不能调整大小,类似于 C++ 的 malloc()
  ```js
  // 申请4个字节的内存
  const b1 = new ArrayBuffer(4);
  // 00000000 00000000 00000000 00000000
  ```
- DataView - 第一种允许读写 ArrayBuffer 的视图
  - 专为 文件I/O 和 网络I/O 设计,其API支持对缓冲数据的高度控制,但性能要差些
  - DataView 使用 ElementType 来实现 JS 的 Number 类型到缓冲内二进制格式的转换
  - ElementType
    - Int8 / 1字节 / 8位有符号整数 / C: signed char / -128~127
    - Uint8 / 1字节 / 8位无符号整数 / C: unsigned char / 0~255
    - Int16 / 2字节 / 16位有符号整数 / C: short
    - Uint16 / 2字节 / 16位无符号整数 / C: unsigned short
    - Int32 / 4字节 / 32位有符号整数 / C: int
    - Uint32 / 4字节 / 32位无符号整数 / C: unsigend int
    - Float32 / 4字节 / 32位 IEEE-754浮点数 float
    - Float64 / 8字节 / 64位 IEEE-754浮点数 double
  - 字节序 - 计算机系统维护的一种字节顺序的约定
    - DataView 只支持2种约定: 大端字节序 和 小端字节序
    - 大端字节序也称为 "网络字节序",从最后一个字节往前读
    - 小端字节序,从第一个字节往后读
  ```js
  // 00000000 00000000 00000000 00000000
  const view1 = new DataView(b1, 2);
  // 00000000 00000000 00000001 10010000
  view1.setInt16(0, 400);
  // 00000000 00000000 00000001 01111110
  view1.setInt8(1, 126);

  // 大端字节序读取  parseInt('00000001 01111110', 2)
  view1.getInt16(0); // 382
  // 小端字节序读取: parseInt('01111110 00000001', 2)
  view1.getInt16(0, true); // 32257
  ```
- 定型数组 - 另一种形式的视图
  - 定型数组与DataView的区别在于,它特定于一种 ElementType 且 遵循系统原生的字节序
  ```js
  // 定型数组
  const int1 = new Int8Array(b1);

  // 00000000 00000000 00000000
  const int2 = new Int8Array(3);

  // 00000000 00000000 00000000 00000000
  let int3 = new Uint8Array([0, 0, 0, 0]);
  // 11111111 11111111 11111111 11111111
  int3 = int3.map(x => 2**8 - 1);

  // 11111111 11111111 11111111 11111111
  let int4 = Uint8Array.of(255, 255, 255, 255);
  // 11111111 00000001 00000001 00000002
  int4.set(Uint16Array.of(1, 1, 2), 1);

  // 00000001 00000001
  const int5 = int4.subarray(1, 3);
  ```

### Map - 映射
- ES6之前,JS中 "键/值" 存储可以使用 Object 方便高效地完成
- Map的键名的范围不限于字符串,各种类型的值(包括对象)都可以当作键名,是一种更完善的 Hash 结构实现
  ```js
  // {"a" => "123", "b" => "456", "c" => "678"}
  new Map([
    ['a', '123'],
    ['b', '456'],
  ]).set('c', '678');
  // {"a" => "123", "b" => "456"}
  new Map({
    [Symbol.iterator]: function*() {
      yield ['a', '123'];
      yield ['b', '456'];
    }
  });
  ```
- Map的实例属性和方法
  - Map.prototype.size: 返回成员总数
  - Map.prototype.set(): 设置键值
  - Map.prototype.get(): 获取键值
  - Map.prototype.has(): 某个键是否在Map对象中
  - Map.prototype.delete(): 删除某个键
  - Map.prototype.clear(): 清除所有成员
  - 遍历方法
    - *Map的遍历顺序就是插入顺序*
    - Map.prototype.keys(): 返回键名的遍历器
    - Map.prototype.values(): 返回键值的遍历器
    - Map.prototype.entries(): 返回所有成员的遍历器,等于 `map1[Symbol.iterator]`
    - Map.prototype.forEach(): 遍历所有成员

### WeakMap - 弱映射
- WeakMap与Map类似,但与Map有2个区别：
  - 1.WeakMap只接受对象作为键名(null除外)
  - 2.WeakMap的键名指向的对象,不计入垃圾回收机制(*弱引用的只是键名,键值仍然正常引用*)
    - WeakMap 中 "weak" 表示弱映射的键是 "弱弱的拿着"
- WeakMap的设计目的: 有时我们想在某个对象上存放一些数据, 但这会形成对对象对引用
  ```js
  // 已回收obj
  let obj = { a: 123 };
  const wmap1 = new WeakMap();
  wmap1.set(obj, [1, 2, 3]);
  obj = null;

  // 未回收obj
  let obj = { a: 123 };
  const wmap1 = new Map();
  wmap1.set(obj, [1, 2, 3]);
  obj = null;
  ```

### Set - 集合
- 类似于数组,但成员的值都是唯一的,没有重复的值
- Set函数可以接受一个数组(或具有 iterable 接口的其它数据结构) 作为参数,用来初始化
- 通过 add() 方法向Set结构加入成员,Set结构不会添加重复的值
  ```js
  // {"a", "b"}
  new Set({
    [Symbol.iterator]: function*() {
      yield 'a';
      yield 'b';
    }
  });
  // {1, 2, 3}
  new Set([1, 2]).add(2).add(3);
  ```
- 判重依据
  - 向 Set 加入值的时候,不会发送类型转换,所以5和"5"是2个不同的值
  - Set内部使用"Same-value-zero equality"判断两个值是否相同,类似于精确相等运算符(===)
  - 主要区别: NaN === NaN // false, Set则认为相等
- Set实例的属性和方法
  - Set.prototype.size: 返回Set实例的成员总数
  - 操作方法
    - Set.prototype.add(): 添加某个值
    - Set.prototype.delete(): 删除某个值
    - Set.prototype.has(): 该值是否为Set的成员
    - Set.prototype.clear(): 清除所有成员
  - 遍历方法
    - *由于Set结构没有键名,只有键值(或者说键名和键值是同一个值),keys和values方法的行为完全一致*
    - Set.prototype.keys(): 返回键名的遍历器
    - Set.prototype.values(): 返回键值的遍历器
    - Set.prototype.entries(): 返回键值对的遍历器
    - Set.prototype.forEach(): 使用回调函数遍历每个成员

### WeakSet - 弱集合
- WeakSet结构与Set类似,但与Set有2个区别:
  - 1.WeakSet的成员只能是对象,不能是其它类型的值
  - 2.WeakSet中的对象都是弱引用,即垃圾回收机制不考虑 WeakSet 对该对象的引用
- *垃圾回收机制何时运行是不可预测的,因此es6规定WeakSet不可遍历*
- *WeakSet的一个用处,是存储DOM节点,而不用担心这些节点从文档移除时,会引发内存泄露*

### JSON

### Promise

### 迭代器 Iterator
- 实现了正式的 *Iterable 接口* 的结构称为 "*可迭代对象*"(iterable),可以通过 *迭代器 Iterator* 消费
- 可迭代对象,暴露一个属性 Symbol.iterator => 迭代器工厂函数,调用工厂函数必须返回一个 迭代器A
- 很多内置类型都实现了 Iterable 接口：字符串、数组、映射、集合、arguments对象、NodeList DOM集合类型
  - 实际写代码过程中，不需要显试调用这个工厂函数来生成迭代器
    - 可接收可迭代对象的原生语言结构包括：
    - 1.for-of 循环
    - 2.数组解构 `[a, b] = new Set(['h', 'e']);`
    - 3.扩展操作符 `[...arr] = 'hello';`
    - 4.Arary.from()
    - 5.创建映射、集合 `Map([]) Set([]) WeakMap([]) WeakSet([])`
    - 6.Promise.all() / Promise.race() 接收由期约组成的可迭代对象
    - 7.yield*操作符,在生成器中使用
      ```js
      let gen = function* () { yield 1; yield* [2, 3, 4]; };
      let iter = gen();
      [...iter] // [1, 2, 3, 4, 5]
      ```
  - 迭代器A 是一种一次性使用的对象
    - next() 方法返回迭代器对象 IteratorResult { done: false, value: 23 }
    - 不同的迭代器的实例之间没有联系
      ```js
      const arr = ['a', 'b'];
      const iter1 = arr[Symbol.iterator]();
      const iter2 = arr[Symbol.iterator]();
      iter1.next(); // {value: "a", done: false}
      iter2.next(); // {value: "a", done: false}
      iter1.next(); // {value: "b", done: false}
      ```
    - 迭代器并不与可迭代对象某个时刻的快照绑定,仅仅使用游标来记录遍历可迭代对象的历程
      - 如果可迭代对象在迭代期间被修改了,那么迭代器也会反应相应的变化
- 自定义迭代器
  - 对象形式
    ```js
    // 可迭代对象
    const obj = {
      [Symbol.iterator]: function () {
        // 迭代器A
        return {
          i: 0,
          next: function() {
            this.i++;
            if (this.i > 2) {
              return {done: true, value: undefined}
            }
            return {done: false, value: this.i};
          }
        };
      }
    };
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // [1, 2]

    // Symbol.iterator 也可迭代
    const obj = {
      i: 0,
      [Symbol.iterator]: function () {
        // 迭代器A
        return this;
      },
      next: function() {
        this.i++;
        if (this.i > 2) {
          return {done: true, value: undefined}
        }
        return {done: false, value: this.i};
      },
    };
    const iter = obj[Symbol.iterator]();
    console.log([...obj]);
    console.log([...iter]);
    ```
  - 生成器形式
    ```js
    // 可迭代对象
    const obj = {
      [Symbol.iterator]: function * () {
        yield 1;
        yield 2;
      }
    };
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // [1, 2]
    ```
  - 类形式,实例只能被迭代一次
    ```js
    class Obj {
      i = 0;
      [Symbol.iterator]() {
        return this;
      }
      next() {
        this.i++;
        if (this.i > 2) {
          return {done: true, value: undefined}
        }
        return {done: false, value: this.i};
      }
    }
    const obj = new Obj();
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // []
    ```
  - 类形式
    ```js
    class Obj {
      [Symbol.iterator]() {
        let i = 0;
        return {
          next() {
            i++;
            if (i > 2) {
              return {done: true, value: undefined}
            }
            return {done: false, value: i};
          }
        };
      }
    }
    const obj = new Obj();
    const iter = obj[Symbol.iterator]();
    iter.next(); // {done: false, value: 1}
    iter.next(); // {done: false, value: 2}
    iter.next(); // {done: true, value: undefined}
    [...obj]; // [1,2]
    ```
- 提前终止迭代器
  - 可选的 return() 方法用于指定迭代器提前关闭前执行的逻辑
  - 可能的情况包括:
    - 1.for-of 循环通过 break、contine、return、throw 提前退出
    - 2.解构操作并未消费所有值
  - return() 方法必须返回一个有效的 IteratorResult 对象, {done: true}
  - return 不会控制 迭代器是否关闭(是否 可以从上次离开的地方继续迭代)

### 生成器 Generator / GeneratorFunction
- 生成器的形式是一个函数,函数名称前面加个 星号(*) 表示它是一个生成器
- 只要是可以定义函数的地方,就可以定义生成器 *箭头函数不能用来定义生成器函数*
- 调用生成器函数会产生一个 生成器对象(具有next方法)
- 生成器对象实现了 Iteralbe 接口,*它默认的迭代器是自引用的*
  ```js
  function * G() {
    yield 1; yield 2; yield 3;
  }
  const g = G();
  g[Symbol.iterator]() === g // true !!! 它默认的迭代器是自引用的
  g.next(); // {value: 1, done: false}
  [...g]; // [2, 3]
  ```
- yield的应用
  - 获取某个范围的数组
    ```js
    function * range(a, b) {
      while (a < b + 1) {
        yield a++;
      }
    }
    for (let x of range(3, 5)) {
      console.log(x);
    }
    ```
  - 递归
    ```js
    function * f1(n) {
      if (n > 0) {
        yield* f1(n - 1);
        yield n - 1;
      }
    }
    console.log([...f1(10)]);
    ```
  - 斐波那契数列
    ```js
    function * f2(n) {
      let a = 1, b = 1;
      let i = 1;
      while (i <= n) {
        yield a;
        [a, b] = [b, a + b];
        i++;
      }
    }
    console.log([...f2(10)]);
    ```
- 提前终止生成器
  - return() 方法会强制生成器进入关闭状态,提供给return()方法的值,就是迭代器对象的值
    ```js
    function * f1() {
      yield 1; yield 2; yield 3;
    }
    const t1 = f1();
    t1.next(); // {value: 1, done: false}
    t1.return(4); // {value: 4, done: true}
    t1.next(); // {value: undefined, done: true}
    ```
  - throw() 方法会在暂停的时候将一个提供的错误注入到生成器对象,若错误未处理,生成器就会关闭
    ```js
    function * f1() {
      yield 1; yield 2; yield 3;
    }
    const t1 = f1();
    t1.next(); // {value: 1, done: false}
    try {
      t1.throw('error info');
    } catch (e) {
      console.log(e); // error info
    }
    t1.next(); // {value: undefined, done: true}
    ```

### AsyncFunction

### Reflect
### Proxy

### 对象:国际化
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.ListFormat
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Locale

### 对象:WebAssembly
WebAssembly
WebAssembly.Module
WebAssembly.Instance
WebAssembly.Memory
WebAssembly.Table
WebAssembly.CompileError
WebAssembly.LinkError (en-US)
WebAssembly.RuntimeError