> https://muyiy.cn/blog/5/5.1.html
### 构造函数(function) / 实例对象(object)
- 定义：
  - 构造函数本身就是一个普通函数，不过为了规范一般将其首字母大写
  - 使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数
- Symbol 不是构造函数
  - 因为它不支持 new Symbol()，如果要生成实例直接所使用 Symbol() 即可
  - 虽然是基本数据类型，但 Symbol(123) 实例可以获取 constructor 属性值，即 Symbol.prototype.constructor
- constructor 值只读吗
  - 对于引用类型来说，constructor 是可以修改的，但对于基本类型来说是只读的
  - null / undefined 没有 constructor 属性，因为创建他们的是只读的原生构造函数(native constructor)
- 模拟实现 new
  - new 运算符创建一个 用户定义的对象类型的实例 或 具有构造函数的内置对象的实例
  - new 创建的实例 a 有以下2个特性：具有构造函数 A 里的属性；a.__proto__继承 A.prototype 里的属性
  - const a = new A('red'); 发生以下事情：
    - 1. 一个继承自 A.prototype 的新对象被创建：let a = new Object(); a.__proto__ = A.ptototype;
      - 优化1：let a = new Object(); Object.setPrototypeOf(a, A.prototype);
      - 优化2：let a = Object.create(A.prototype);
    - 2. 使用指定的参数调用构造函数 A，并将 this 绑定到新创建的对象：A.apply(a, ['red'])
    - 3. 由构造函数返回的对象就是 new 表达式的结果；若没有显式返回一个对象，则使用1创建的对象
  - 优化：const res = A.apply(a, ['red']); res instanceof Object ?
  - 题目：实现 add(1)(2)(3)(4)

### 原型对象(object)
- __proto__ 属性在 ES6 时才被标准化，以确保 Web 浏览器兼容性，但不推荐使用，除了标准化的原因之外还有性能问题
  - 为了更好的支持，推荐使用 Object.getPrototypeof() / Object.setPrototypeof()
- 如果要创建一个对象，同时继承另一个对象的 __proto__，推荐使用 Object.create()

### 原型链
- 原型链定义：每个对象拥有一个原型对象，通过 __proto__ 指针指向上一个原型，并从中继承方法和属性。
  - 同时原型对象也可能拥有原型，这样一层一层，最终指向 null，这就是原型链。
  - 创建一个没有原型链的对象 `Object.create(null, {})`
- 原型链示例：
  1. const arr = new Array(); `arr -> Array.prototype -> Object.prototype -> null`
  2. function f() {} `f -> Function.prototype -> Object.prototype -> null`
  3. const s = '123'; `s -> String.prototype -> Object.prototype -> null`

### instanceof 原理及实现
- 原理：instanceof 就是一层层查找 __proto__，如果 和 右侧的构造函数.prototype 相等则返回true, 若一直没找到则返回false
- 模拟实现 instanceof
  ```js
  function instanceOf(L, R) {
    let point = L;
    while (point.__proto__) {
      if (point.__proto__ === R.prototype) return true;
      point = point.__proto__;
    }
    return false;
  }
  ```

### 原型链继承
- 定义：本质是重写原型对象，代之以一个新类型的实例
- 示例：B的原型对象不仅有了 A 构造函数的全部属性和方法，还指向了 A 的原型，继承了 A 原型上的属性和方法
  ```js
  function A(color) {
    this.color = color;
  }
  A.prototype.getColor = function() {
    return this.color;
  }
  function B() {}

  const a = new A('red');
  B.prototype = a;
  // 等价于：
  // const obj = Object.create(A.prototype);
  // B.prototype = obj;
  // A.apply(B.prototype, ['red']);

  // constructor 修正
  B.prototype.constructor = B;

  const b = new B();
  ```
- 原型链继承方案的缺点
  - 1. 多个实例对 b.__proto__ 上引用类型 的操作会篡改，对于基础类型 会在自身建立属性
  - 2. 子类型原型上的 constructor 属性(B.prototype.constructor)被重写了，可以修正
  - 3. 给子类型原型添加属性和方法 必须在替换原型之后，因为子类型的原型会被a覆盖
  - 4. 属性遮蔽，子类型原型上与父类型的同名，可以通过 b.__proto__.getColor 访问到

### 3种判断数组的方法，介绍区别与优劣
- 0. typeof 无法判定
- 1. Object.prototype.toString.call(arr)
  - 各种类型
- 2. arr instanceof Array
  - 原型链可能被程序修改
    ```js
    const arr = [];
    arr.__proto__ = {};
    arr instanceof Array; // false
    ```
  - 无法检测 iframes
    ```js
    const arr = new window.frames.Array(1, 2, 3);
    arr instanceof Array; // false
    ```
- 3. Array.isArray(arr)
  - 假如不存在 Array.isArray(), 可在其它代码运行前 Polyfill
    ```js
    if (! Array.isArray) {
      Array.isArray = function (arg) {
        return Object.prototype.toString.call(arg) === '[object Array]'
      }
    }
    ```

### Function & Object 鸡蛋问题(Function.__proto__ === Function.prototype)
```js
typeof Object.__proto__ // function
typeof Function.__proto__ // function

Object instanceof Function // true
// Object.__proto__ === Function.prototype

Function instanceof Object // true
// Function.__proto__.__proto__ === Object.prototype

Object instanceof Object // true
Object.__proto__.__proto__ === Object.prototype

Function instanceof Function // true
// Function.__proto__ === Function.prototype
```
- 对于 `Function.__proto__ === Function.prototype` 的2种解释
  - 1. function Function 是 Function 的实例
    - 因此 a instanceof b 为 true
  - 2. function Function 不是 Function 的实例
    - Function 是 built-in 的对象，也就是不存在 "Function 对象是由 Function 构造函数创建" 这样鸡生蛋蛋生鸡的问题
    - 即现有 Function.prototype，然后有的 function Function()
    - 把 Function.__proto__ 指向 Function.prototype 是为了保证原型链的完整，让 Fucntion 可以获取定义在 Object.prototype 上的方法
