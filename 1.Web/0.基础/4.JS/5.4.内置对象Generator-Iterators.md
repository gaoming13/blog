### 1.1 迭代器
- 迭代器规则：
  - 迭代器是对象
  - 通过 `next()` 方法实现遍历对象
  - 正常返回 `{done:false,value:值}`, 最后一个值返回 `{done:true,value:undefined}`
- 根据迭代器规则手工创建迭代器
  ```js
  const myIterable = {
    i: 0,
    next: function() {
      this.i++;
      if (this.i > 3) {
        return {done: true, value: undefined}
      }
      return {done: false, value: this.i};
    }
  }
  console.log(myIterable.next()); // {done: false, value: 1}
  console.log(myIterable.next()); // {done: false, value: 2}
  console.log(myIterable.next()); // {done: false, value: 3}
  console.log(myIterable.next()); // {done: true, value: undefined}
  console.log(myIterable.next()); // {done: true, value: undefined}
  ```

### 1.2 生成器函数(`function*` 用来生成迭代器对象)
- 1.调用构造函数，返回一种成为 Generator 的迭代器
- 2.通过调用生成器的 next() 方法消耗值时，Generator 函数将执行，直到遇到 yield 关键字

```js
// 生成器函数
function* M(num) {
  let i = 1;
  while(i <= num) {
    yield i;
    i++;
  }
}
// 遍历1:
const it = M(3);
console.log(it.next()); // {value: 1, done: false}
console.log(it.next()); // {value: 2, done: false}
console.log(it.next()); // {value: 3, done: false}
console.log(it.next()); // {value: undefined, done: true}
console.log(it.next()); // {value: undefined, done: true}
/* 原型链：
it(object)
> __proto__               => M.prototype

M(function)
> prototype               => Generator.prototype
> constructor
> Symbol(Symbol.toStringTag): 'GeneratorFunction'
> __proto__               => [Function.prototype]

Generator(function)
> prototype
  > constructor(self)
  > next: f
  > return: f
  > throw: f
  > Symbol(Symbol.toStringTag): "Generator"
  > __proto__
    > Symbol(Symbol.iterator): ƒ
    > __proto__           => [Object.prototype]
> Symbol(Symbol.toStringTag): "GeneratorFunction"
> __proto__               => [Function.prototype]
*/

// 遍历2: [1, 2, 3]
console.log([...M(3)]);

// 遍历3: 1 2 3
for (const v of M(3)) {
  console.log(v);
}
```

### 2.1 可迭代对象(不一定为迭代器)
- 若一个对象拥有迭代行为，比如可用 `for..of` 循环，那么该对象为可迭代对象
- 为了实现迭代，一个对象必须实现 `@@iterator` 方法，意味着这个对象（或其原型链中）必须具有一个带 `Symbol.iterator` 键的属性
- `String`/`Array`/`Map`/`Set` 都是内置可迭代对象，因为它们的原型对象中都拥有一个 `Symbol.iterator` 方法
- 自定义可迭代对象
  ```js
  const myIterable = {
    *[Symbol.iterator]() {
      yield 1;
      yield 2;
    }
  }
  console.log([...myIterable]); // [1, 2]
  ```