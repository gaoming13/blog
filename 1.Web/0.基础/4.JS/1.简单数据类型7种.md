## 简单数据类型7种(也称原始类型)

### 1.undefined
- 未知初始化变量(变量声明了，但没初始化)

### 2.null
- 空对象指针

### 3.boolean
- 转型方法：可以调用 Boolean() 转型函数
  - String: 非空字符串 -> true, 空字符串 -> false
  - Number: 非零值(包括Infinate) -> true, 0、NaN -> false
  - Object: 任意对象 -> true, null -> false
  - Undefined: undefined -> false

### 4.number
- 64位,采用IEEE754标准的64位双精度浮点数 *{1:符号位(0正1负)}{10:指数部分e}{53:小数部分}*
- 最大最小安全整数
  - 最大安全整数 = `parseInt('1'.repeat(53), 2)` = Number.MAX_SAFE_INTEGER = 9007199254740991 = 2**53-1
  - 最小安全整数 = `-1 * parseInt('1'.repeat(53), 2)` = Number.MIN_SAFE_INTEGER = -9007199254740991
  - 再大或再小表示会不准确：`Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2` => true
- Number.MAX_VALUE 与 java的Double.MAX_VALUE一致
- *为什么：0.1+0.2 = 0.30000000000000004*
  - 计算机只认识二进制,在进行运算时,需要转换为2进制,再进行计算
  - 对于十进制,它只能表示以进制数的质因子为分母的分数
    - 10的质因子有2和5,因此 1/2、1/4、1/5、1/8、1/10 都可精确表示,但 1/3、1/6、1/7 都是循环小数
  - 对于二进制,质因子有2,因此 1/2、1/4、1/8 都可精确表示,但 1/5、1/10 都是循环小数
  - (0.1).toString(2) = 0.0001100110011001100110011001100110011001100110011001101
  - (0.2).toString(2) = 0.001100110011001100110011001100110011001100110011001101
- 转型方法：可以调用 Number()、parseInt()、parseFloat()
  - Number() *一元加操作符与Number()函数遵循相同的转化规则*
    - 布尔值：true -> 1, false -> 0
    - 数值 -> 直接返回
    - null -> 0
    - undefined -> NaN
    - '' -> 0, '123abc' -> NaN, '0xE1' -> 225
  - parseInt()
    - 布尔值 -> NaN
    - 数值 -> 小数点后去除(floor)
    - null -> NaN
    - undefined -> NaN
    - '' -> NaN, '123abc' -> 123, parseInt('0xE1', 16)
  - parseFloat() *只解析十进制*
- `+Infinity`(正无穷)、`-Infinity`(负无穷)  - 特性参照：*2.标准内置对象*
- NaN (not-a-number非数字) - 特性参照：*2.标准内置对象*
- 进制字面量
  - 二进制：0b101 === 0B101 === 5
  - 八进制：0o154 === 0O154 === 0154 === 108
    - 0154 在严格模式下会报错：Uncaught SyntaxError: Octal literals are not allowed in strict mode.
  - 十六进制：0x3ea === 0X3ea === 1002
  - `1E3` `2e6 === 2000000` 指数形式(科学计数法)(1x10的3次方)

### 5.bigint
- 按照IEEE 754,所有数字都以双精度64位浮点格式表示,非常大的整数将自动四舍五入,整数溢出:
  - 9007199254740992 === 9007199254740993 // true
  - console.log(9999999999999999) // 10000000000000000
- 1.要创建BigInt, 只需在整数末尾追加n即可
  - console.log(9007199254740995n) // 9007199254740995n
  - console.log(9007199254740995) // 9007199254740994
- 2.或者调用BigInt()构造函数
  - BigInt(9007199254740995) // 9007199254740995n
- 3.也可以用二进制、八进制、十六进制表示
  - 0b100000000000000000000000000000000000000000000000000011n // 9007199254740995n
  - 0o400000000000000003n // 9007199254740995n
  - 0x20000000000003n // 9007199254740995n
- 4.*不要使用严格相等运算符将BigInt与常规数字进行比较,因为它们的类型不同* 10n===10 // false
- 5.除一元加号(+)运算符外,所有运算符都可用于BigInt
  - 除法(/)运算符的结果会自动向下舍入到最接近的整数 25n/10n // 2n
- *1.不能使用Number和BigInt操作数的混合执行算数运算, 需要显式转换其中一种数据类型*
- *2.处于兼容性原因,不允许在BigInt上使用一元加号(+)运算符*

### 6.string
- 表示0个或多个 *16位 Unicode 字符序列*
- 可以使用 双引号(")、单引号(')、反引号(`) 来表示
- 字符字面量
  - \n 换行(换到下一行当前位置)
  - \r 回车(回到行首) - js不太支持
  - \t 制表; \f 换页; \\ 反斜杠; \' 单引号; \" 双引号; \` 反引号;
  - \x41 十六进制编码，等于 A
  - \u03a3 十六进制编码的 Unicode 字符，等于 Σ
    - \uD842\uDFB7 等于 '吉'
    - \u{7A} 等于 'z'
- length 返回字符串中 16位字符的 个数，若包含双字节字符，返回就不准确
- toString() 方法，在对数值调用这个方法时，可以接收一个底数参数（什么进制的字符串）
  - (123).toString(16) === '7b'
- 转型方法：可以调用 String() 转型函数，始终返回表示相应类型值的字符串
  - 若值有 toString() 方法，则调用该方法
  - null -> 'null'
  - undefined -> 'undefined'
- 模板字面量
  - 模板字面量*会保持反引号内部的空格*
  - 模板字面量在定义时，立即求值并转换为字符串实例
  -
  ```js
  let s1 = `Hello ${name},
  World`;
  ```
- 模板字面量标签函数
  - 标签函数本身就是一个常规函数，标签函数接收到的参数依次为：原始字符串数组 + 对每个表达式求值的结果
  ```js
  let a = 6,b = 9;
  function tag(strings, ...expressions) {
    console.log(strings);
    console.log(expressions);
  }
  tag`${a} + ${b} = ${a + b}`; // ["", " + ", " = ", ""] [6, 9, 15]
  ```
- 原始字符串：使用模板字面量可以直接获取原始的模板字面量内容(如换行符 或 Unicode 字符)，而不是被转换后的字符表示
  - String.raw`\u00A9` // \u00A9
  ```js
  // String.raw 的实现
  const stringRaw = (strings) => strings.raw.join();
  stringRaw`\u00A9`;
  ```

### 7.symbol
- 符号是原始值，且符号实例是唯一、不可变的
- 符号的用途是 *确保对象属性使用唯一的标识符*，不会发生属性冲突的风险
- 调用 Symbol() 函数时，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个描述来调试代码
- 使用全局符号注册表
  - Symbol.for() 接收一个字符串作参数,搜索有无相同参数名称的Symbol值,有则返回,没有新建后返回,并注册到全局
    - `Symbol.for('a') === Symbol.for('a')` // true
  - Symbol.keyFor() 返回一个已登记的 Symbol 类型值的字符串键
    - `Symbol.keyFor(Symbol.for('foo'))` // foo
    - `Symbol.keyFor(Symbol('foo'))` // undefined
- 使用 符号 作为属性
  ```js
  let sym = Symbol();
  let a = {}; a[sym] = 'hello';
  let a = { [sym]: 'hello' };
  let a = {}; Object.defineProperty(a, sym, { value: 'Hello' });
  // 常规属性 (自身可枚举 + 自身不可枚举)
  Object.getOwnPropertyNames(obj);
  // 符号属性 (自身可枚举 + 自身不可枚举)
  Object.getOwnPropertySymbols(obj);
  // 以上之和
  Reflect.ownKeys(obj);
  ```
- 实例1：消除魔术字符串
  ```js
  // 魔术字符串是指: 代码中多次出现、与代码形成强耦合的某个特定字符串或数值
  // 风格良好的代码,应尽量消除魔术字符串,改由含义清晰的变量代替
  function getArea(shape, options) {}
  getArea('Triangle', { width: 100, height: 100 });

  // 优化后：
  const shareType = {
    triangle: Symbol('Symbol'),
  };
  function getArea(shape, options) {}
  getArea(shareType.triangle, { width: 100, height: 100 });
  ```
- 实例2：单例模式(Singleton)
  ```js
  function A () {
    console.log('11');
  }
  const key = Symbol.for('A1');
  if (! global[key]) {
    global[key] = new A();
  }
  export default global[key];
  ```
- 常用内置符号
  - es6提供了多个内置符号值，用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为
  - S
- 1.Symbol.hasInstance: 其它对象使用 instanceof 运算符, 判断是否为该对象实例时
  *foo instanceof Foo, 在语言内部, 实际调用的是 Foo[Symbol.hasInstance](foo)*
  ```js
  // 形式1
  class MyClass {
    [Symbol.hasInstance](obj) {
      return obj instanceof Array;
    }
  }
  [1, 2, 3] instanceof new MyClass() // true
  // 形式2
  class MyClass {
    static [Symbol.hasInstance](obj) {
      return obj instanceof Array;
    }
  }
  [1, 2, 3] instanceof MyClass // true
  // 形式3
  const MyClass = {
    [Symbol.hasInstance](obj) {
      return obj instanceof Array;
    }
  }
  [1, 2, 3] instanceof MyClass // true
  ```
- 2.Symbol.isConcatSpreadable: 对象用于 Array.prototype.concat() 时,是否可以展开
  ```js
  let arr = ['c', 'd'];
  ['a', 'b'].concat(arr, 'e') // ["a", "b", "c", "d", "e"]
  arr[Symbol.isConcatSpreadable] // undefined

  let arr = ['c', 'd'];
  arr[Symbol.isConcatSpreadable] = false;
  ['a', 'b'].concat(arr, 'e') // ["a", "b", ["c", "d"], "e"]
  ```
- 3.Symbol.species: 修改子类继承者
  ```js
  // true
  class MyArray extends Array {}
  const z1 = new MyArray(1, 2, 3);
  console.log((z1.map(v => v)) instanceof MyArray);

  // false
  class MyArray extends Array {
    static get [Symbol.species]() {
      return Array;
    }
  }
  const z1 = new MyArray(1, 2, 3);
  console.log((z1.map(v => v)) instanceof MyArray);
  ```
- 4.Symbol.match: 对象被 String.prototype.match 方法调用时
- 5.Symbol.replace: 对象被 String.prototype.replace 方法调用时
  - `String.prototype.replace(searchValue, replaceValue)` 等同于
  - `searchValue[Symbol.replace](this, replaceValue)`
  ```js
  const x = {
    [Symbol.replace](...s) {
      console.log(s);
    }
  };
  'Hello'.replace(x, 'Word');
  ```
- 6.Symbol.search: 对象被 String.prototype.search 方法调用时
  - `String.prototype.search(regexp)` 等同于
  - `regexp[Symbol.search](this)`
- 7.Symbol.split: 对象被 String.prototype.split 方法调用时
  - `String.prototype.split(separator, limit)` 等同于
  - `separator[Symbol.split](this, limit)`
  ```js
  class MySplitter {
    constructor(value) {
      this.value = value;
    }
    [Symbol.split](s) {
      return [s, this.value];
    }
  }
  'footbar'.split(new MySplitter('foo'));
  ```
- 8.Symbol.iterator: 对象的默认遍历器方法
  ```js
  let obj = {
    *[Symbol.iterator]() {
      yield 1;
      yield 2;
      yield 3;
    }
  };
  [...obj];
  ```
- 9.Symbol.toPrimitive: 对象被转换为原始类型的值时,会调用这个方法
  ```js
  let obj = {
    [Symbol.toPrimitive](hint) {
      switch (hint) {
        case 'number': return 123;
        case 'string': return 'abc';
        case 'default': return 'default';
        default: throw new Error();
      }
    }
  };
  Number(obj); // 123
  String(obj); // 'abc'
  3 + obj; // 3default
  ```
- 10.Symbol.toStringTag: 在对象上调用 Object.prototype.toString 方法时
  ```js
  // [object Foo]
  ({[Symbol.toStringTag]: 'Foo'}.toString())

  // [object xxx]
  class MyClass {
    get [Symbol.toStringTag]() {
      return 'xxx';
    }
  }
  (new MyClass()).toString();
  ```
- 11.Symbol.unscopables: 指定了使用with关键字时,哪些属性会被with环境排除
  ```js
  // 1
  class MyClass {
    foo() { return 1; }
  }
  with (MyClass.prototype) {
    foo();
  }
  // foo is not defined
  class MyClass {
    foo() { return 1; }
    get [Symbol.unscopables]() {
      return { foo: true };
    }
  }
  with (MyClass.prototype) {
    foo();
  }
  ```



### typeof 操作符
1. typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）
2. typeof null === 'object'，这是因为特殊值 null 被认为是 *一个对空对象的引用*
3. 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据结构
  - 可是，函数也有自己特殊的属性，为此就有必要用 typeof 来区分函数和其它对象
```js
typeof undefined; // undefined
typeof null; // object
typeof true; // boolean
typeof 88; // number
typeof 88n; // bigint
typeof 'abc'; // string
typeof Symbol('a'); // symbol
typeof function() {} // function
```
