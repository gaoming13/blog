## 简单数据类型7种(也称原始类型)

### 1.undefined
- 未知初始化变量(变量声明了，但没初始化)

### 2.null
- 空对象指针

### 3.boolean
- 转型方法：可以调用 Boolean() 转型函数
  - String: 非空字符串 -> true, 空字符串 -> false
  - Number: 非零值(包括Infinate) -> true, 0、NaN -> false
  - Object: 任意对象 -> true, null -> false
  - Undefined: undefined -> false

### 4.number
- 64位,采用IEEE754标准的64位双精度浮点数 *{1:符号位(0正1负)}{10:指数部分e}{53:小数部分}*
- 最大最小安全整数
  - 最大安全整数 = `parseInt('1'.repeat(53), 2)` = Number.MAX_SAFE_INTEGER = 9007199254740991 = 2**53-1
  - 最小安全整数 = `-1 * parseInt('1'.repeat(53), 2)` = Number.MIN_SAFE_INTEGER = -9007199254740991
  - 再大或再小表示会不准确：`Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2` => true
- Number.MAX_VALUE 与 java的Double.MAX_VALUE一致
- *为什么：0.1+0.2 = 0.30000000000000004*
  - 计算机只认识二进制,在进行运算时,需要转换为2进制,再进行计算
  - 对于十进制,它只能表示以进制数的质因子为分母的分数
    - 10的质因子有2和5,因此 1/2、1/4、1/5、1/8、1/10 都可精确表示,但 1/3、1/6、1/7 都是循环小数
  - 对于二进制,质因子有2,因此 1/2、1/4、1/8 都可精确表示,但 1/5、1/10 都是循环小数
  - (0.1).toString(2) = 0.0001100110011001100110011001100110011001100110011001101
  - (0.2).toString(2) = 0.001100110011001100110011001100110011001100110011001101
- 转型方法：可以调用 Number()、parseInt()、parseFloat()
  - Number() *一元加操作符与Number()函数遵循相同的转化规则*
    - 布尔值：true -> 1, false -> 0
    - 数值 -> 直接返回
    - null -> 0
    - undefined -> NaN
    - '' -> 0, '123abc' -> NaN, '0xE1' -> 225
  - parseInt()
    - 布尔值 -> NaN
    - 数值 -> 小数点后去除(floor)
    - null -> NaN
    - undefined -> NaN
    - '' -> NaN, '123abc' -> 123, parseInt('0xE1', 16)
  - parseFloat() *只解析十进制*
- `+Infinity`(正无穷)、`-Infinity`(负无穷)  - 特性参照：*2.标准内置对象*
- NaN (not-a-number非数字) - 特性参照：*2.标准内置对象*
- 进制字面量
  - 二进制：0b101 === 0B101 === 5
  - 八进制：0o154 === 0O154 === 0154 === 108
    - 0154 在严格模式下会报错：Uncaught SyntaxError: Octal literals are not allowed in strict mode.
  - 十六进制：0x3ea === 0X3ea === 1002
  - `1E3` `2e6 === 2000000` 指数形式(科学计数法)(1x10的3次方)

### 5.bigint
- 按照IEEE 754,所有数字都以双精度64位浮点格式表示,非常大的整数将自动四舍五入,整数溢出:
  - 9007199254740992 === 9007199254740993 // true
  - console.log(9999999999999999) // 10000000000000000
- 1.要创建BigInt, 只需在整数末尾追加n即可
  - console.log(9007199254740995n) // 9007199254740995n
  - console.log(9007199254740995) // 9007199254740994
- 2.或者调用BigInt()构造函数
  - BigInt(9007199254740995) // 9007199254740995n
- 3.也可以用二进制、八进制、十六进制表示
  - 0b100000000000000000000000000000000000000000000000000011n // 9007199254740995n
  - 0o400000000000000003n // 9007199254740995n
  - 0x20000000000003n // 9007199254740995n
- 4.*不要使用严格相等运算符将BigInt与常规数字进行比较,因为它们的类型不同* 10n===10 // false
- 5.除一元加号(+)运算符外,所有运算符都可用于BigInt
  - 除法(/)运算符的结果会自动向下舍入到最接近的整数 25n/10n // 2n
- *1.不能使用Number和BigInt操作数的混合执行算数运算, 需要显式转换其中一种数据类型*
- *2.处于兼容性原因,不允许在BigInt上使用一元加号(+)运算符*

### 6.string
- 表示0个或多个 *16位 Unicode 字符序列*
- 可以使用 双引号(")、单引号(')、反引号(`) 来表示
- 字符字面量
  - \n 换行(换到下一行当前位置)
  - \r 回车(回到行首) - js不太支持
  - \t 制表; \f 换页; \\ 反斜杠; \' 单引号; \" 双引号; \` 反引号;
  - \x41 十六进制编码，等于 A
  - \u03a3 十六进制编码的 Unicode 字符，等于 Σ
    - \uD842\uDFB7 等于 '吉'
    - \u{7A} 等于 'z'
- length 返回字符串中 16位字符的 个数，若包含双字节字符，返回就不准确
- toString() 方法，在对数值调用这个方法时，可以接收一个底数参数（什么进制的字符串）
  - (123).toString(16) === '7b'
- 转型方法：可以调用 String() 转型函数，始终返回表示相应类型值的字符串
  - 若值有 toString() 方法，则调用该方法
  - null -> 'null'
  - undefined -> 'undefined'
- 模板字面量
  - 模板字面量*会保持反引号内部的空格*
  - 模板字面量在定义时，立即求值并转换为字符串实例
  -
  ```js
  let s1 = `Hello ${name},
  World`;
  // 嵌套
  let animals = ['dog', 'cat', 'hourse'];
  console.log(`<ul>${animals.map(animal => `<li>${animal}</li>`)}</ul>`);
  ```
- 模板字面量标签函数
  - 标签函数本身就是一个常规函数，标签函数接收到的参数依次为：原始字符串数组 + 对每个表达式求值的结果
  ```js
  let a = 6,b = 9;
  function tag(strings, ...expressions) {
    console.log(strings);
    console.log(expressions);
  }
  tag`${a} + ${b} = ${a + b}`; // ["", " + ", " = ", ""] [6, 9, 15]
  ```
- 原始字符串：使用模板字面量可以直接获取原始的模板字面量内容(如换行符 或 Unicode 字符)，而不是被转换后的字符表示
  - String.raw`\u00A9` // \u00A9
  ```js
  // String.raw 的实现
  const stringRaw = (strings) => strings.raw.join();
  stringRaw`\u00A9`;
  ```

### 7.symbol
- 符号是原始值，且符号实例是唯一、不可变的
- 符号的用途是 *确保对象属性使用唯一的标识符*，不会发生属性冲突的风险
- 调用 Symbol() 函数时，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个描述来调试代码
- 使用全局符号注册表
  - Symbol.for() 接收一个字符串作参数,搜索有无相同参数名称的Symbol值,有则返回,没有新建后返回,并注册到全局
    - `Symbol.for('a') === Symbol.for('a')` // true
  - Symbol.keyFor() 返回一个已登记的 Symbol 类型值的字符串键
    - `Symbol.keyFor(Symbol.for('foo'))` // foo
    - `Symbol.keyFor(Symbol('foo'))` // undefined
- 使用 符号 作为属性
  ```js
  let sym = Symbol();
  let a = {}; a[sym] = 'hello';
  let a = { [sym]: 'hello' };
  let a = {}; Object.defineProperty(a, sym, { value: 'Hello' });
  // 常规属性 (自身可枚举 + 自身不可枚举)
  Object.getOwnPropertyNames(obj);
  // 符号属性 (自身可枚举 + 自身不可枚举)
  Object.getOwnPropertySymbols(obj);
  // 以上之和
  Reflect.ownKeys(obj);
  ```
- 实例1：消除魔术字符串
  ```js
  // 魔术字符串是指: 代码中多次出现、与代码形成强耦合的某个特定字符串或数值
  // 风格良好的代码,应尽量消除魔术字符串,改由含义清晰的变量代替
  function getArea(shape, options) {}
  getArea('Triangle', { width: 100, height: 100 });

  // 优化后：
  const shareType = {
    triangle: Symbol('Symbol'),
  };
  function getArea(shape, options) {}
  getArea(shareType.triangle, { width: 100, height: 100 });
  ```
- 实例2：单例模式(Singleton)
  ```js
  function A () {
    console.log('11');
  }
  const key = Symbol.for('A1');
  if (! global[key]) {
    global[key] = new A();
  }
  export default global[key];
  ```
- 常用内置符号
  - es6提供了多个内置符号值，用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为
  - Symbol.iterator 同步迭代
    - 要加符号的主体：for (v of 主体)
    - 默认主体的符号属性：`[].__proto__[Symbol.iterator]`
    ```js
    let obj = { *[Symbol.iterator]() { yield 1; yield 2; } };
    for (const v of obj) console.log(v);
    ```
  - Symbol.asyncIterator 异步迭代
    - 主体是被迭代的对象
    ```js
    let obj = {
      async *[Symbol.asyncIterator]() {
        yield new Promise(resolve => setTimeout(() => resolve(true), 1000));
        yield new Promise(resolve => setTimeout(() => resolve(true), 1000));
      }
    };
    (async () => {
      for await (const v of obj) console.log(v);
    })();
    ```
  - Symbol.hasInstance
    - 要加符号的主体：obj instanceof 主体
    - 默认主体的符号属性：`({}).__proto__.constructor.__proto__[Symbol.hasInstance]`
    - 一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例
    - `a instanceof A`, 在语言内部, 实际调用的是 `A[Symbol.hasInstance](a)`
    ```js
    // 形式1
    class A { [Symbol.hasInstance](obj) { return obj instanceof Array; } }
    [1, 2, 3] instanceof new A() // true
    // 形式2
    class A { static [Symbol.hasInstance](obj) { return obj instanceof Array; } }
    [1, 2, 3] instanceof A // true
    // 形式3
    const A = { [Symbol.hasInstance](obj) { return obj instanceof Array; } }
    [1, 2, 3] instanceof A // true
    ```
  - Symbol.isConcatSpreadable 布尔值，对象用于 Array.prototype.concat() 时，是否展开
    - 要加符号的主体：[].concat(主体)
    - 默认主体的符号属性：无
    - 调用的方法：Array.prototype.concat
    ```js
    let arr = ['c', 'd'];
    ['a', 'b'].concat(arr, 'e') // ["a", "b", "c", "d", "e"]
    arr[Symbol.isConcatSpreadable] // undefined

    let arr = ['c', 'd'];
    arr[Symbol.isConcatSpreadable] = false;
    ['a', 'b'].concat(arr, 'e') // ["a", "b", ["c", "d"], "e"]
    ```
  - Symbol.match
    - 要加符号的主体：'abc'.match(主体)
    - 默认主体的符号属性：`RegExp.prototype[Symbol.match]`
    - 调用的方法：String.prototype.match
    ```js
    var obj = { [Symbol.match](s) { return 123; } }
    'abc'.match(obj); // 123
    ```
  - Symbol.replace
    - 要加符号的主体：'abc'.replace(主体, '123')
    - 默认主体的符号属性：`RegExp.prototype[Symbol.replace]`
    - 调用的方法：String.prototype.replace
    ```js
    const x = { [Symbol.replace](searchVal, replaceVal) { return '123'; } };
    'Hello'.replace(x, 'Word'); // 123
    ```
  - Symbol.search
    - 要加符号的主体：'abc'.search(主体, '123')
    - 默认主体的符号属性：`RegExp.prototype[Symbol.search]`
    - 调用的方法：String.prototype.search
    ```js
    const x = { [Symbol.search](s) { return '123'; } };
    'Hello'.search(x); // 123
    ```
  - Symbol.split
    - 要加符号的主体：'abc'.split(主体)
    - 默认主体的符号属性：`RegExp.prototype[Symbol.split]`
    - 调用的方法：String.prototype.split
    ```js
    const x = { [Symbol.split](target, limit) { return '123'; } };
    console.log('Hello'.split(x, 2)); // 123
    ```
  - Symbol.species 修改子类继承者
    - 默认主体的符号属性：`[].__proto__.constructor[Symbol.species]`
    - 该符号属性：一个函数值，用于创建派生对象的构造函数
    ```js
    // true
    class A extends Array {}
    const z1 = new A(1, 2, 3);
    console.log((z1.map(v => v)) instanceof A);

    // false
    class A extends Array {
      static get [Symbol.species]() {
        return Array;
      }
    }
    const z1 = new A(1, 2, 3);
    console.log((z1.map(v => v)) instanceof A);
    ```
  - Symbol.toPrimitive 对象被转换为原始类型的值时,会调用这个方法
    ```js
    let obj = {
      [Symbol.toPrimitive](hint) {
        switch (hint) {
          case 'number': return 123;
          case 'string': return 'abc';
          case 'default': return 'default';
          default: throw new Error();
        }
      }
    };
    Number(obj); // 123
    String(obj); // 'abc'
    3 + obj; // 3default
    ```
  - Symbol.toStringTag
    ```js
    // [object Foo]
    ({[Symbol.toStringTag]: 'Foo'}.toString())

    // [object xxx]
    class A {
      get [Symbol.toStringTag]() {
        return 'xxx';
      }
    }
    (new A()).toString();
    ```
  - Symbol.unscopables 指定了使用with关键字时,哪些属性会被with环境排除
    - 严格模式下不允许使用 with 语句
    - `Array.prototype[Symbol.unscopables]`
    ```js
    // 1
    class A {
      foo() { return 1; }
    }
    with (A.prototype) {
      foo();
    }
    // foo is not defined
    class A {
      foo() { return 1; }
      get [Symbol.unscopables]() {
        return { foo: true };
      }
    }
    with (A.prototype) {
      foo();
    }
    ```

### typeof 操作符 - 来判断原始值类型
1. typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）
2. typeof null === 'object'，这是因为特殊值 null 被认为是 *一个对空对象的引用*
3. 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据结构
  - 可是，函数也有自己特殊的属性，为此就有必要用 typeof 来区分函数和其它对象
```js
typeof undefined; // undefined
typeof null; // object
typeof true; // boolean
typeof 88; // number
typeof 88n; // bigint
typeof 'abc'; // string
typeof Symbol('a'); // symbol
typeof function() {} // function
```

### instanceof 操作符 - 来判断对象类型
```js
[] instanceof Array; // true
```