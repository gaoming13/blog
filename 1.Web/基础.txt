#### Javascript
- this:
  - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this
  - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arrow_functions
  - 在绝对多数情况下,函数的调用方式决定了`this`的值。`this`不能在执行期间被赋值，每次函数被调用时`this`的值也有可能不同。
  - ES5引入了`bind`方法来设置函数的`this`值，而不用考虑函数如何被调用的
  - ES2015引入了支持`this`词法解析的箭头函数(它在闭合的执行环境内设置`this`的值)
  - 1.全局环境中: 都指向全局对象 `console.log(this);` => `window`
  - 2-1.函数简单调用,非严格模式: 调用的函数未设置this时,默认指向全局对象 `(function() { console.log(this); })();` => `window`
  - 2-2.函数简单调用,严格模式: this保持他进入执行环境时的值,如果this没有被执行环境(execution context)定义,那它将保持为`undefined`
    - `(function() { 'use strict'; console.log(this); })();` => `undefined`
    - 如果想把this的值从一个环境传到另一个,可用`call`或`apply`方法
      - `(function() { 'use strict'; console.log(this); }).call({ a: 123 })` => `{a: 123}`
    - 当一个函数在其主体内使用this关键字时,可以使用函数继承自`Function.prototype`的`call`或`apply`将this绑定到调用中的特定对象
      - `(function(c, d) { console.log(this.a + this.b + c + d); }).call({ a: '1', b: '2' }, '3', '4')` => `1234`
      - `(function(c, d) { console.log(this.a + this.b + c + d); }).apply({ a: '1', b: '2' }, ['3', '4'])` => `1234`
  - 3.bind方法：ES2015引入的`Function.prototype.bind`,调用`f.bind(obj)`会创建一个与f具有相同函数体和作用域的函数,this永久被绑定到obj,无论函数如何被调用
    - `function f() { console.log(this); }; var f1 = f.bind({a: '123'}); var f2 = f1.bind({a: '456'}); var obj = { f1, f2 };`
    - `console.log(obj.f1()); console.log(obj.f2());` => `{a: '123'}  {a: '123'}`
  - 4.对象的方法: 函数作为对象中的方法被调用时，this是调用该函数的对象; 这样的行为不受函数定义方式或位置的影响
    - `var obj = {a: '123', obj1: { b: '345', f: function() { return this } }}` => `{b: '345', f}`
    - `function f() { return this }; var obj = {a: '123', f}; obj.f()` => `{a: '123', f}`
  - 5.原型链中的方法：同上, 如果方法存在于对象的原型链上，那么this是调用这个方法的对象
    - `var obj = {f: function() { return this; }}; var obj1 = Object.create(obj); obj1.a = '123'; obj1.f()` => `{a: '123'}`
  - 6.getter与setter中：同上，this是设置或获取属性的对象
    - `var obj = {a: '123', b: {c: '456'}}; Object.defineProperty(obj.b, 'd', {get: function() { return this }}); obj.b.d` => `{c: '456'}`
  - 7.构造函数：当一个函数用作构造函数时(使用new关键字), this是正在构造的新对象；虽然构造器默认返回this指的对象,但可手动返回其它对象
    - `function C() { this.a = '123'; console.log(this); return {b: '456'}; }; new C()` => `C {a: "123"} {b: "456"}`
  - 8.dom事件处理函数：
    - `$0.addEventListener('click', function() { console.log(this); })` => `当前元素`
    - `$0.addEventListener('click', function() { (function() { console.log(this); })(); })` => `window`
  - 9.内联事件处理函数
    - `onclick="console.log(this);"` => `当前元素`
    - `onclick="(function() { console.log(this); })()"` => `window`
  - 10.箭头函数: this与封闭词法环境的this保持一致,即被设置为创建他时的环境; 如果通过`call/apply/bind`传递this,它将被忽略;
    - `(() => this)() === this` => `true`
    - `(() => this).call({a: 123}) === this` => `true`
    - `var obj = {f: function() { return () => this }}; (obj.f())() === obj` => `true`
    - `var obj = {f: function() { return () => this }}; var obj1 = {a: 123, f: obj.f}; (obj1.f())() === obj` => `false`
    - 箭头函数不能用作构造器,和new一起用会抛出错误 `var C = () => {}; new C();` // // TypeError: Foo is not a constructor
    - 箭头函数没有prototype属性 `var f = () => {}; f.prototype;` // undefined
    - 箭头函数也可以使用闭包
      - 标准闭包函数: `function f() { var i = 0; return function() { return ++i; } }; var a = f(); a(); a();`
      - 箭头函数的闭包：`var f = (i = 0) => () => ++i; var a = f(); a(); a();`
- 严格模式(es5)
  - 1.通过抛出错误来消除一些原有静默错误
    - 八进制语法: `var n = 023; var s = "\047"` // ES6 `var n = Oo23`
    - with语句
    - 使用delete删除变量名(而非属性名) `delete a`
    - 删除一个不可配置的属性 `delete Object.prototype`
    - 使用`eval`或`arguments`作为变量名或函数名
    - 对象字面量中使用相同的属性名：`{a:1, b:2, a:3}`
    - 函数形参中使用相同的参数名：`function f(a, b, b) {}`
    - 给一个未声明的变量赋值 `a = 123`
  - 2.修复了一些导致Javascript引擎难以执行优化的缺陷,有时候相同代码严格模式执行更快.
    - 在语句块中使用函数声明 `if (a > b) { function f() {} }`
    - 访问 `arguments.callee, arguments.caller, anyFunction.caller以及anyFunction.arguments`
    - 普通函数调用f()中,this指向全局变量;严格模式中,this指向undefined,使用call或apply可传入this参数
    - 严格模式下arguments对象会以形参变量的拷贝形式被创建和初始化，因此arguments对象的改变不会影响形参
    - 严格模式下eval不会在当前的作用域内创建新变量,传入eval的字符串参数也会按照严格模式去解析
  - 3.禁用了ECMAScript在未来版本中可能用到的语法
    - 使用未来保留字作为变量名或函数名(implements/interface/let/package/private/procted/public/static/yield)
- `'a' in { a: '123' }` 如果指定的属性在指定的对象或原型链中，则 `in` 运算符返回 `true`
- 求a.x `var a = {n: 1}; var b = a; a.x = a = { n: 2 }`
  - // a ---> x1({n: 1}) <--- b
  - // a ---> x2({n: 2}), x1({n: 1}) <--- b
  - // a ---> x2({n: 2}), x1({n: 1, x: {n: 2}}) <--- b
- 求a和b `(() => { var a = b = 3 })()`
  - 等价于：b = 3; var a = b;

### Console对象
- 对象输出
  - log: function(message, [...values]) 输出信息
  - info: function(message, [...values]) log的别名
  - warn: function(message, [...values]) 输出警告信息
  - error: function(message, [...values]) 输出错误信息+堆栈
  - trace: function(message, [...values]) 输出错误信息+堆栈
  - dir: function(object) 与log没啥区别似乎
  - dirxml: function(object) 与log没啥区别似乎
  - table: function(data, [columns]) 以表格形式输出对象
- 分组显示
  - group: function([name]) 开始分组
  - groupCollapsed: function([name]) 开始分组(默认折叠)
  - groupEnd: function([name]) 结束分组
- 计时功能
  - time: function(name = "default") 开始计时
  - timeEnd: function(name = "default") 结束计时
- assert: function(condition, [message], [...values]) 断言,如果结果为否,输出相应信息,并抛出异常
- count: function([label]) 输出它被调用了多少次
- clear: function() 清除当前控制台的所有输出,光标回至首行